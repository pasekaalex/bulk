<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <title>BULK RUNNER - Infinite Runner</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Bangers&family=Press+Start+2P&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            background: #000;
            overflow: hidden;
            font-family: 'Press Start 2P', monospace;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            position: fixed;
            width: 100%;
            height: 100%;
            overscroll-behavior: none;
        }
        
        /* Prevent pull-to-refresh on mobile */
        html {
            overscroll-behavior: none;
            position: fixed;
            width: 100%;
            height: 100%;
        }
        
        #game-container { 
            width: 100vw; 
            height: 100vh; 
            position: relative;
        }
        
        canvas { 
            display: block; 
            width: 100%;
            height: 100%;
        }
        
        #ui-overlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        
        #title-screen {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(135deg, #2d1b4e 0%, #1a0a2e 30%, #0d0d0d 70%, #1a0a2e 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            pointer-events: all;
        }
        
        #title-screen.hidden { display: none; }
        
        .title-main {
            font-family: 'Bangers', cursive;
            font-size: clamp(3rem, 10vw, 6rem);
            color: #9b30ff;
            text-shadow: 0 0 10px #ff00ff, 0 0 20px #ff00ff, 0 0 40px #9b30ff, 4px 4px 0 #000;
            letter-spacing: 0.1em;
            animation: titlePulse 0.5s ease-in-out infinite alternate;
            text-align: center;
            margin-bottom: 20px;
        }
        
        @keyframes titlePulse { from { transform: scale(1); } to { transform: scale(1.05); } }
        
        .subtitle {
            font-size: clamp(0.8rem, 2vw, 1.2rem);
            color: #ffd93d;
            margin-top: 10px;
            text-shadow: 2px 2px 0 #000;
            text-align: center;
        }
        
        .instructions {
            font-size: clamp(0.5rem, 1.2vw, 0.7rem);
            color: #fff;
            margin-top: 30px;
            text-align: center;
            line-height: 2;
            max-width: 600px;
            padding: 0 20px;
        }
        
        .start-btn {
            margin-top: 40px;
            padding: clamp(16px, 4vw, 20px) clamp(40px, 10vw, 60px);
            font-family: 'Bangers', cursive;
            font-size: clamp(1.5rem, 4vw, 2.5rem);
            background: linear-gradient(180deg, #9b30ff 0%, #6b0099 100%);
            color: #fff;
            border: 4px solid #ff00ff;
            border-radius: 10px;
            cursor: pointer;
            text-shadow: 2px 2px 0 #000;
            box-shadow: 0 0 20px #9b30ff;
            transition: all 0.1s;
            animation: btnFloat 1s ease-in-out infinite;
            pointer-events: all;
            min-height: 44px;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
        
        @keyframes btnFloat { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-10px); } }
        
        .start-btn:hover {
            background: linear-gradient(180deg, #bf5fff 0%, #9b30ff 100%);
            transform: scale(1.1);
        }
        
        #game-ui {
            position: absolute;
            top: max(20px, env(safe-area-inset-top));
            left: max(20px, env(safe-area-inset-left));
            color: #fff;
            font-size: clamp(10px, 2.5vw, 14px);
            text-shadow: 2px 2px 0 #000, 0 0 10px rgba(0,0,0,0.8);
            z-index: 20;
        }
        
        #score {
            font-size: clamp(12px, 3vw, 18px);
            color: #ffd93d;
            margin-bottom: 10px;
            text-shadow: 2px 2px 0 #000, 0 0 15px rgba(255, 217, 61, 0.5);
            transition: transform 0.2s;
        }
        
        #score.pulse {
            transform: scale(1.2);
        }
        
        #distance {
            font-size: clamp(10px, 2.5vw, 14px);
            color: #9b30ff;
            text-shadow: 2px 2px 0 #000, 0 0 10px rgba(155, 48, 255, 0.5);
        }
        
        #speed-indicator {
            font-size: clamp(8px, 2vw, 12px);
            color: #ff6b6b;
            margin-top: 5px;
            text-shadow: 2px 2px 0 #000, 0 0 10px rgba(255, 107, 107, 0.5);
        }
        
        #game-over {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
            pointer-events: all;
        }
        
        #game-over.show { display: flex; }
        
        .game-over-title {
            font-family: 'Bangers', cursive;
            font-size: clamp(2rem, 6vw, 4rem);
            color: #ff6b6b;
            text-shadow: 0 0 10px #ff0000, 4px 4px 0 #000;
            margin-bottom: 20px;
        }
        
        .final-score {
            font-size: clamp(1rem, 3vw, 1.5rem);
            color: #ffd93d;
            margin-bottom: 30px;
        }
        
        .restart-btn {
            padding: clamp(12px, 3vw, 15px) clamp(30px, 8vw, 40px);
            font-family: 'Bangers', cursive;
            font-size: clamp(1rem, 3vw, 1.5rem);
            background: linear-gradient(180deg, #9b30ff 0%, #6b0099 100%);
            color: #fff;
            border: 4px solid #ff00ff;
            border-radius: 10px;
            cursor: pointer;
            text-shadow: 2px 2px 0 #000;
            box-shadow: 0 0 20px #9b30ff;
            transition: all 0.1s;
            min-height: 44px;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
        
        .restart-btn:hover {
            background: linear-gradient(180deg, #bf5fff 0%, #9b30ff 100%);
            transform: scale(1.1);
        }
        
        .back-btn {
            margin-top: 20px;
            padding: clamp(10px, 2.5vw, 12px) clamp(25px, 6vw, 30px);
            font-size: clamp(0.7rem, 2vw, 0.8rem);
            background: rgba(155, 48, 255, 0.3);
            color: #fff;
            border: 2px solid #9b30ff;
            border-radius: 8px;
            cursor: pointer;
            text-decoration: none;
            transition: all 0.1s;
            min-height: 44px;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            display: inline-block;
        }
        
        .back-btn:hover {
            background: rgba(155, 48, 255, 0.5);
        }
        
        #controls-hint {
            position: absolute;
            bottom: max(20px, env(safe-area-inset-bottom));
            left: 50%;
            transform: translateX(-50%);
            font-size: clamp(0.5rem, 1.5vw, 0.6rem);
            color: rgba(255, 255, 255, 0.7);
            text-align: center;
            z-index: 20;
            padding: 0 20px;
            opacity: 0.6;
            animation: fadeInOut 3s ease-in-out infinite;
        }
        
        @keyframes fadeInOut {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 0.3; }
        }
        
        .action-feedback {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Bangers', cursive;
            font-size: clamp(2rem, 8vw, 4rem);
            color: #ffd93d;
            text-shadow: 0 0 20px #ffd93d, 4px 4px 0 #000;
            pointer-events: none;
            z-index: 30;
            opacity: 0;
            transition: opacity 0.3s, transform 0.3s;
        }
        
        .action-feedback.show {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1.2);
        }
        
        .action-feedback.jump {
            color: #9b30ff;
            text-shadow: 0 0 20px #9b30ff, 4px 4px 0 #000;
        }
        
        .action-feedback.slide {
            color: #ff6b6b;
            text-shadow: 0 0 20px #ff6b6b, 4px 4px 0 #000;
        }
        
        @media (max-width: 768px) {
            #controls-hint {
                font-size: 0.5rem;
            }
            
            .instructions {
                font-size: clamp(0.4rem, 1.5vw, 0.6rem);
                line-height: 1.8;
            }
            
            #title-screen {
                padding: 20px;
            }
        }
        
        @media (max-width: 480px) {
            #game-ui {
                top: max(10px, env(safe-area-inset-top));
                left: max(10px, env(safe-area-inset-left));
            }
            
            #controls-hint {
                bottom: max(10px, env(safe-area-inset-bottom));
                font-size: 0.4rem;
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="title-screen">
            <div class="title-main">BULK RUNNER</div>
            <div class="subtitle">INFINITE RUNNER</div>
            <div class="instructions">
                SWIPE LEFT/RIGHT to change lanes<br>
                SWIPE UP to jump<br>
                SWIPE DOWN to slide<br>
                Avoid obstacles and run as far as you can!
            </div>
            <button class="start-btn" onclick="startGame()">START RUNNING</button>
        </div>
        
        <div id="game-ui">
            <div id="score">SCORE: 0</div>
            <div id="distance">DISTANCE: 0m</div>
            <div id="speed-indicator">SPEED: 1.0x</div>
        </div>
        
        <div id="controls-hint">
            ← → Move | ↑ Jump | ↓ Slide
        </div>
        
        <div class="action-feedback" id="action-feedback"></div>
        
        <div id="game-over">
            <div class="game-over-title">GAME OVER</div>
            <div class="final-score" id="final-score">FINAL SCORE: 0</div>
            <button class="restart-btn" onclick="restartGame()">PLAY AGAIN</button>
            <a href="index.html" class="back-btn">BACK TO HOME</a>
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    
    <script type="module">
        // Global error handler
        window.addEventListener('error', (e) => {
            console.error('Global error:', e.error);
            const titleScreen = document.getElementById('title-screen');
            if (titleScreen && !titleScreen.classList.contains('hidden')) {
                let errorMsg = e.error ? e.error.message : 'Unknown error';
                let helpText = '';
                
                if (errorMsg.includes('WebGL') || errorMsg.includes('context')) {
                    helpText = `
                        <div style="color: #ffd93d; font-size: 0.5rem; margin-top: 15px; line-height: 1.8; max-width: 500px; padding: 0 20px;">
                            TIPS:<br>
                            • Update your browser to the latest version<br>
                            • Update your graphics drivers<br>
                            • Try a different browser (Chrome, Firefox, Edge)<br>
                            • Check if hardware acceleration is enabled in browser settings
                        </div>
                    `;
                }
                
                titleScreen.innerHTML = `
                    <div class="title-main">BULK RUNNER</div>
                    <div class="subtitle" style="color: #ff6b6b; margin-top: 20px;">
                        Error: ${errorMsg}
                    </div>
                    ${helpText}
                    <button class="start-btn" onclick="location.reload()" style="margin-top: 30px;">RELOAD</button>
                `;
            }
        });
        
        // Handle unhandled promise rejections
        window.addEventListener('unhandledrejection', (e) => {
            console.error('Unhandled promise rejection:', e.reason);
            const titleScreen = document.getElementById('title-screen');
            if (titleScreen && !titleScreen.classList.contains('hidden')) {
                titleScreen.innerHTML = `
                    <div class="title-main">BULK RUNNER</div>
                    <div class="subtitle" style="color: #ff6b6b; margin-top: 20px;">
                        Failed to load game
                    </div>
                    <div style="color: #fff; font-size: 0.6rem; margin-top: 20px; max-width: 500px; padding: 0 20px;">
                        ${e.reason ? e.reason.toString() : 'Unknown error'}
                    </div>
                    <button class="start-btn" onclick="location.reload()" style="margin-top: 30px;">RELOAD PAGE</button>
                `;
            }
        });
        
        // Load Three.js modules
        let THREE, GLTFLoader, FBXLoader;
        let modulesLoaded = false;
        
        (async () => {
            try {
                THREE = await import('three');
                const GLTFLoaderModule = await import('https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/GLTFLoader.js');
                GLTFLoader = GLTFLoaderModule.GLTFLoader;
                
                // Try to load FBXLoader (optional, for fallback)
                // Note: FBXLoader requires additional dependencies (inflate, fflate, etc.)
                try {
                    // First try the standard import
                    const FBXLoaderModule = await import('https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/FBXLoader.js');
                    FBXLoader = FBXLoaderModule.FBXLoader;
                    console.log('FBXLoader loaded successfully');
                } catch (e) {
                    console.warn('FBXLoader not available (may need additional dependencies), will skip FBX fallback:', e);
                    // FBXLoader might not work without additional dependencies, that's okay
                }
                
                modulesLoaded = true;
                
                // Initialize game after modules load
                if (document.readyState === 'loading') {
                    document.addEventListener('DOMContentLoaded', () => {
                        if (modulesLoaded) initializeGameScene();
                    });
                } else {
                    setTimeout(() => {
                        if (modulesLoaded) initializeGameScene();
                    }, 100);
                }
            } catch (error) {
                console.error('Failed to load Three.js:', error);
                const titleScreen = document.getElementById('title-screen');
                if (titleScreen) {
                    titleScreen.innerHTML = `
                        <div class="title-main">BULK RUNNER</div>
                        <div class="subtitle" style="color: #ff6b6b; margin-top: 20px;">
                            Failed to load game engine
                        </div>
                        <div style="color: #fff; font-size: 0.6rem; margin-top: 20px; max-width: 500px; padding: 0 20px; line-height: 1.8;">
                            Please check your internet connection and refresh the page.
                        </div>
                        <button class="start-btn" onclick="location.reload()" style="margin-top: 30px;">RELOAD PAGE</button>
                    `;
                }
            }
        })();
        
        let scene, camera, renderer;
        let bulkModel, bulkMixer;
        let gameStarted = false;
        let gameOver = false;
        let score = 0;
        let distance = 0;
        let speed = 0.3;
        let baseSpeed = 0.3;
        let currentLane = 1; // 0 = left, 1 = center, 2 = right
        let lanePositions = [-2, 0, 2];
        let isJumping = false;
        let isSliding = false;
        let jumpVelocity = 0;
        let gravity = -0.02;
        let groundY = 0;
        let bulkBaseY = 0; // Store the base Y position from bounding box calculation
        let obstacles = [];
        let trackSegments = [];
        let lastObstacleZ = 0;
        let lastTrackZ = 0;
        let particles = [];
        let particleSystem = null;
        let combo = 0;
        let lastComboTime = 0;
        let cameraShake = { x: 0, y: 0, intensity: 0 };
        
        // Touch/Mouse controls
        let touchStartX = 0;
        let touchStartY = 0;
        let touchEndX = 0;
        let touchEndY = 0;
        
        function init() {
            // Check if Three.js loaded
            if (typeof THREE === 'undefined' || !THREE) {
                throw new Error('Three.js failed to load. Please check your internet connection.');
            }
            
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a0a2e);
            scene.fog = new THREE.Fog(0x1a0a2e, 50, 200);
            
            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 3, 8);
            camera.lookAt(0, 1, 0);
            
            // Renderer with device pixel ratio for mobile
            const container = document.getElementById('game-container');
            if (!container) {
                throw new Error('Game container not found');
            }
            
            // Check for WebGL support with detailed diagnostics
            function checkWebGLSupport() {
                try {
                    const canvas = document.createElement('canvas');
                    
                    // Try WebGL 2 first
                    let gl = canvas.getContext('webgl2');
                    if (gl) {
                        console.log('WebGL 2.0 supported');
                        return { supported: true, version: 2, context: gl };
                    }
                    
                    // Try WebGL 1
                    gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                    if (gl) {
                        console.log('WebGL 1.0 supported');
                        return { supported: true, version: 1, context: gl };
                    }
                    
                    // Check if WebGL is disabled
                    const debugInfo = gl ? gl.getExtension('WEBGL_debug_renderer_info') : null;
                    if (debugInfo) {
                        const vendor = gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL);
                        const renderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
                        console.log('WebGL Info - Vendor:', vendor, 'Renderer:', renderer);
                    }
                    
                    return { supported: false, version: 0, context: null };
                } catch (e) {
                    console.error('WebGL check error:', e);
                    return { supported: false, version: 0, context: null, error: e.message };
                }
            }
            
            const webglCheck = checkWebGLSupport();
            if (!webglCheck.supported) {
                const errorMsg = webglCheck.error 
                    ? `WebGL check failed: ${webglCheck.error}`
                    : 'WebGL is not supported in your browser. Please try a different browser or update your graphics drivers.';
                throw new Error(errorMsg);
            }
            
            // Try to create WebGL renderer with fallbacks
            let rendererCreated = false;
            let lastError = null;
            const rendererOptions = [
                { antialias: true, powerPreference: "high-performance", alpha: false },
                { antialias: true, powerPreference: "default", alpha: false },
                { antialias: false, powerPreference: "default", alpha: false },
                { antialias: false, powerPreference: "low-power", alpha: false },
                { antialias: false, powerPreference: "low-power", alpha: true }
            ];
            
            for (let i = 0; i < rendererOptions.length; i++) {
                const options = rendererOptions[i];
                try {
                    console.log(`Attempting to create renderer with options ${i + 1}/${rendererOptions.length}:`, options);
                    renderer = new THREE.WebGLRenderer(options);
                    
                    // Check if renderer was actually created
                    if (!renderer || !renderer.domElement) {
                        console.warn('Renderer created but domElement is missing');
                        continue;
                    }
                    
                    // Verify the context exists
                    const canvas = renderer.domElement;
                    const gl = canvas.getContext('webgl') || canvas.getContext('webgl2') || canvas.getContext('experimental-webgl');
                    if (!gl) {
                        console.warn('Renderer created but WebGL context is null');
                        continue;
                    }
                    
                    console.log('Renderer created successfully with options:', options);
                    rendererCreated = true;
                    break;
                } catch (e) {
                    lastError = e;
                    console.warn(`Failed to create renderer with options ${i + 1}:`, options, e);
                    continue;
                }
            }
            
            if (!rendererCreated || !renderer) {
                const errorDetails = lastError ? ` Error: ${lastError.message}` : '';
                throw new Error(`Failed to create WebGL context after trying ${rendererOptions.length} different configurations.${errorDetails}`);
            }
            
            try {
                const pixelRatio = Math.min(window.devicePixelRatio, 2); // Limit to 2x for performance
                renderer.setPixelRatio(pixelRatio);
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                
                // Clear the container first
                while (container.firstChild) {
                    container.removeChild(container.firstChild);
                }
                
                container.appendChild(renderer.domElement);
                
                // Test if we can actually render something
                renderer.setClearColor(0x1a0a2e, 1);
                renderer.clear();
                renderer.render(scene, camera);
                
                console.log('WebGL renderer initialized successfully');
            } catch (e) {
                console.error('Renderer initialization error:', e);
                throw new Error('Failed to initialize renderer: ' + (e.message || 'Unknown WebGL error'));
            }
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0x9b30ff, 1);
            directionalLight.position.set(5, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -10;
            directionalLight.shadow.camera.right = 10;
            directionalLight.shadow.camera.top = 10;
            directionalLight.shadow.camera.bottom = -10;
            scene.add(directionalLight);
            
            const pointLight = new THREE.PointLight(0xff00ff, 0.5, 100);
            pointLight.position.set(0, 5, 0);
            scene.add(pointLight);
            
            // Additional rim lighting
            const rimLight1 = new THREE.DirectionalLight(0xffd93d, 0.3);
            rimLight1.position.set(-5, 3, 5);
            scene.add(rimLight1);
            
            const rimLight2 = new THREE.DirectionalLight(0xff6b6b, 0.3);
            rimLight2.position.set(5, 3, 5);
            scene.add(rimLight2);
            
            // Create particle system (optional enhancement - skip if it fails)
            createParticleSystem();
            
            // Ground
            createGround();
            
            // Load Bulk model (create placeholder immediately so game can start)
            createPlaceholderModel();
            loadBulkModel();
            
            // Create initial track ahead of player (positive Z values)
            for (let i = 0; i < 20; i++) {
                createTrackSegment(i * 10);
            }
            lastTrackZ = 19 * 10; // Set last track Z to the last segment
            
            // Controls
            setupControls();
            
            // Start animation loop
            animate();
        }
        
        function createGround() {
            // Main ground
            const groundGeometry = new THREE.PlaneGeometry(20, 1000);
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x1a0a2e,
                roughness: 0.9,
                metalness: 0.1
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.2;
            ground.position.z = -500;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // Side barriers for visual depth
            for (let side = -1; side <= 1; side += 2) {
                const barrierGeometry = new THREE.BoxGeometry(0.5, 2, 1000);
                const barrierMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x0d0d0d,
                    emissive: 0x9b30ff,
                    emissiveIntensity: 0.1
                });
                const barrier = new THREE.Mesh(barrierGeometry, barrierMaterial);
                barrier.position.set(side * 10, 1, -500);
                barrier.castShadow = true;
                scene.add(barrier);
            }
        }
        
        function createTrackSegment(z) {
            // Create track with lanes
            for (let lane = 0; lane < 3; lane++) {
                const trackGeometry = new THREE.PlaneGeometry(2, 10);
                const trackMaterial = new THREE.MeshStandardMaterial({ 
                    color: lane === 1 ? 0x4a1d6e : 0x2d1b4e,
                    roughness: 0.7,
                    metalness: 0.1
                });
                const track = new THREE.Mesh(trackGeometry, trackMaterial);
                track.rotation.x = -Math.PI / 2;
                track.position.set(lanePositions[lane], 0, z);
                track.receiveShadow = true;
                scene.add(track);
                trackSegments.push(track);
            }
            
            // Add animated lane markers
            for (let i = 0; i < 2; i++) {
                const markerGeometry = new THREE.PlaneGeometry(0.1, 10);
                const markerMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x9b30ff,
                    emissive: 0x9b30ff,
                    emissiveIntensity: 0.8,
                    transparent: true,
                    opacity: 0.9
                });
                const marker = new THREE.Mesh(markerGeometry, markerMaterial);
                marker.rotation.x = -Math.PI / 2;
                marker.position.set(lanePositions[i] + 1, 0.01, z);
                marker.userData = { originalZ: z, speed: speed };
                scene.add(marker);
            }
        }
        
        function createParticleSystem() {
            try {
                const particleCount = 100;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                
                for (let i = 0; i < particleCount * 3; i++) {
                    positions[i] = (Math.random() - 0.5) * 20;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                
                const material = new THREE.PointsMaterial({
                    color: 0x9b30ff,
                    size: 0.1,
                    transparent: true,
                    opacity: 0.6,
                    blending: THREE.AdditiveBlending
                });
                
                particleSystem = new THREE.Points(geometry, material);
                scene.add(particleSystem);
            } catch (e) {
                console.warn('Particle system creation failed:', e);
                particleSystem = null;
            }
        }
        
        function setupModel(model, modelType = 'GLB') {
            console.log(`Setting up ${modelType} model...`);
            
            // Calculate bounding box to determine proper scale
            const box = new THREE.Box3().setFromObject(model);
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            
            console.log('Model size:', size, 'Max dimension:', maxDim);
            
            // Scale to approximately match the original Bulk size
            const targetHeight = 4; // Smaller for runner game
            const baseScale = maxDim > 0 ? targetHeight / maxDim : 0.1;
            const scale = baseScale;
            console.log('Calculated scale:', scale);
            
            model.scale.set(scale, scale, scale);
            
            // Center the model
            const center = box.getCenter(new THREE.Vector3());
            model.position.set(-center.x * scale, -center.y * scale, -center.z * scale);
            model.rotation.set(0, 0, 0);
            
            // Enable shadows on all meshes
            let meshCount = 0;
            model.traverse((child) => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                    meshCount++;
                }
            });
            console.log('Found', meshCount, 'meshes in model');
            
            // Store model reference
            bulkModel = model;
            
            // Position model based on bounding box
            const bottomY = box.min.y * scale;
            const groundLevel = groundY;
            const clearance = 0.5;
            bulkBaseY = groundLevel - bottomY + clearance;
            bulkModel.position.y = bulkBaseY;
            bulkModel.userData = bulkModel.userData || {};
            bulkModel.userData.baseY = bulkBaseY;
            bulkModel.userData.modelType = modelType;
            
            console.log('Positioned bulk at Y:', bulkBaseY);
            bulkModel.visible = true;
            
            // Remove placeholder if it exists (check both simple placeholder and hulk placeholder)
            scene.children.forEach((child) => {
                if (child.userData && child.userData.isPlaceholder) {
                    scene.remove(child);
                    console.log('Removed placeholder model');
                }
                // Also check if it's a Group with placeholder children
                if (child.isGroup) {
                    child.children.forEach((subChild) => {
                        if (subChild.userData && subChild.userData.isPlaceholder) {
                            scene.remove(child);
                            console.log('Removed placeholder group');
                            return;
                        }
                    });
                }
            });
            
            scene.add(bulkModel);
            
            // Force a render update
            if (renderer) {
                renderer.render(scene, camera);
            }
            
            console.log(`${modelType} model loaded and configured successfully!`);
        }
        
        function loadBulkModel() {
            // Try GLB first (primary)
            if (GLTFLoader) {
                const loader = new GLTFLoader();
                console.log('Attempting to load bulk.glb (primary)...');
                
                loader.load(
                    'bulk.glb',
                    (gltf) => {
                        console.log('GLB loaded successfully!', gltf);
                        
                        const model = gltf.scene || (gltf.scenes && gltf.scenes[0]);
                        if (!model) {
                            console.error('No scene found in GLB file. Trying FBX fallback...');
                            tryLoadFBX();
                            return;
                        }
                        
                        setupModel(model, 'GLB');
                        
                        // Setup animation mixer if animations exist
                        if (gltf.animations && gltf.animations.length > 0) {
                            console.log('Found', gltf.animations.length, 'animations in GLB');
                            bulkMixer = new THREE.AnimationMixer(model);
                            
                            const walkAnim = gltf.animations.find(anim => 
                                anim.name.toLowerCase().includes('walk') || 
                                anim.name.toLowerCase().includes('run') ||
                                anim.name.toLowerCase().includes('idle')
                            );
                            
                            if (walkAnim) {
                                const action = bulkMixer.clipAction(walkAnim);
                                action.setLoop(THREE.LoopRepeat);
                                action.play();
                            } else {
                                gltf.animations.forEach((clip) => {
                                    const action = bulkMixer.clipAction(clip);
                                    action.setLoop(THREE.LoopRepeat);
                                    action.play();
                                });
                            }
                        }
                    },
                    (progress) => {
                        if (progress.lengthComputable) {
                            const percent = (progress.loaded / progress.total * 100).toFixed(0);
                            console.log('Loading GLB:', percent + '%');
                        }
                    },
                    (error) => {
                        console.error('Error loading GLB:', error);
                        console.log('Trying FBX fallback...');
                        tryLoadFBX();
                    }
                );
            } else {
                console.log('GLTFLoader not available, trying FBX...');
                tryLoadFBX();
            }
        }
        
        function tryLoadFBX() {
            // Try FBX second (secondary fallback)
            if (FBXLoader) {
                const loader = new FBXLoader();
                console.log('Attempting to load bulk.fbx (secondary fallback)...');
                
                loader.load(
                    'bulk.fbx',
                    (fbx) => {
                        console.log('FBX loaded successfully!', fbx);
                        setupModel(fbx, 'FBX');
                        
                        // Setup animation mixer if animations exist
                        if (fbx.animations && fbx.animations.length > 0) {
                            console.log('Found', fbx.animations.length, 'animations in FBX');
                            bulkMixer = new THREE.AnimationMixer(fbx);
                            
                            const walkAnim = fbx.animations.find(anim => 
                                anim.name.toLowerCase().includes('walk') || 
                                anim.name.toLowerCase().includes('run') ||
                                anim.name.toLowerCase().includes('idle')
                            );
                            
                            if (walkAnim) {
                                const action = bulkMixer.clipAction(walkAnim);
                                action.setLoop(THREE.LoopRepeat);
                                action.play();
                            }
                        }
                    },
                    (progress) => {
                        if (progress.lengthComputable) {
                            const percent = (progress.loaded / progress.total * 100).toFixed(0);
                            console.log('Loading FBX:', percent + '%');
                        }
                    },
                    (error) => {
                        console.error('Error loading FBX:', error);
                        console.log('Falling back to purple hulk placeholder...');
                        createPurpleHulkPlaceholder();
                    }
                );
            } else {
                console.log('FBXLoader not available, using purple hulk placeholder...');
                createPurpleHulkPlaceholder();
            }
        }
        
        function createPlaceholderModel() {
            // Create a simple box placeholder immediately (temporary, will be replaced)
            const geometry = new THREE.BoxGeometry(1, 2, 1);
            const material = new THREE.MeshStandardMaterial({ 
                color: 0x9b30ff,
                emissive: 0x9b30ff,
                emissiveIntensity: 0.5
            });
            bulkModel = new THREE.Mesh(geometry, material);
            bulkModel.position.set(0, groundY + 1, 0);
            bulkModel.castShadow = true;
            bulkModel.receiveShadow = true;
            bulkModel.userData = { baseY: groundY + 1, isPlaceholder: true };
            bulkBaseY = groundY + 1;
            scene.add(bulkModel);
            console.log('Temporary placeholder model created');
        }
        
        function createPurpleHulkPlaceholder() {
            // Create a rough polygon purple hulk creature (worst fallback)
            console.log('Creating purple hulk placeholder...');
            
            const hulkGroup = new THREE.Group();
            const purpleMat = new THREE.MeshStandardMaterial({ 
                color: 0x9b30ff,
                roughness: 0.6,
                emissive: 0x6b0099,
                emissiveIntensity: 0.3
            });
            const darkPurpleMat = new THREE.MeshStandardMaterial({ 
                color: 0x6b0099,
                roughness: 0.7,
                emissive: 0x4a0080,
                emissiveIntensity: 0.2
            });
            
            // Torso (main body)
            const torso = new THREE.Mesh(
                new THREE.BoxGeometry(1.2, 1.5, 0.8),
                purpleMat
            );
            torso.position.y = 1.2;
            torso.castShadow = true;
            torso.receiveShadow = true;
            hulkGroup.add(torso);
            
            // Head
            const head = new THREE.Mesh(
                new THREE.BoxGeometry(0.9, 0.9, 0.9),
                purpleMat
            );
            head.position.set(0, 2.2, 0);
            head.castShadow = true;
            hulkGroup.add(head);
            
            // Arms
            const leftArm = new THREE.Mesh(
                new THREE.BoxGeometry(0.4, 1.2, 0.4),
                purpleMat
            );
            leftArm.position.set(-0.9, 1.2, 0);
            leftArm.castShadow = true;
            hulkGroup.add(leftArm);
            
            const rightArm = new THREE.Mesh(
                new THREE.BoxGeometry(0.4, 1.2, 0.4),
                purpleMat
            );
            rightArm.position.set(0.9, 1.2, 0);
            rightArm.castShadow = true;
            hulkGroup.add(rightArm);
            
            // Legs
            const leftLeg = new THREE.Mesh(
                new THREE.BoxGeometry(0.5, 1.0, 0.5),
                darkPurpleMat
            );
            leftLeg.position.set(-0.3, 0.3, 0);
            leftLeg.castShadow = true;
            hulkGroup.add(leftLeg);
            
            const rightLeg = new THREE.Mesh(
                new THREE.BoxGeometry(0.5, 1.0, 0.5),
                darkPurpleMat
            );
            rightLeg.position.set(0.3, 0.3, 0);
            rightLeg.castShadow = true;
            hulkGroup.add(rightLeg);
            
            // Feet
            const leftFoot = new THREE.Mesh(
                new THREE.BoxGeometry(0.6, 0.3, 0.8),
                darkPurpleMat
            );
            leftFoot.position.set(-0.3, -0.2, 0.2);
            leftFoot.castShadow = true;
            hulkGroup.add(leftFoot);
            
            const rightFoot = new THREE.Mesh(
                new THREE.BoxGeometry(0.6, 0.3, 0.8),
                darkPurpleMat
            );
            rightFoot.position.set(0.3, -0.2, 0.2);
            rightFoot.castShadow = true;
            hulkGroup.add(rightFoot);
            
            // Position the hulk
            hulkGroup.position.set(0, groundY + 0.5, 0);
            hulkGroup.userData = { baseY: groundY + 0.5, isPlaceholder: true };
            bulkModel = hulkGroup;
            bulkBaseY = groundY + 0.5;
            
            // Remove temporary placeholder if it exists
            scene.children.forEach((child) => {
                if (child.userData && child.userData.isPlaceholder && child.geometry && child.geometry.type === 'BoxGeometry') {
                    scene.remove(child);
                }
            });
            
            scene.add(bulkModel);
            console.log('Purple hulk placeholder created');
        }
        
        function createObstacle(lane, z) {
            const obstacleTypes = ['low', 'high', 'medium'];
            const type = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
            
            let height, yPos, color, emissive;
            
            switch(type) {
                case 'low':
                    height = 1;
                    yPos = 0.5;
                    color = 0xff6b6b;
                    emissive = 0xff0000;
                    break;
                case 'high':
                    height = 3;
                    yPos = 1.5;
                    color = 0xff4444;
                    emissive = 0xff0000;
                    break;
                case 'medium':
                default:
                    height = 2;
                    yPos = 1;
                    color = 0xff5555;
                    emissive = 0xff0000;
                    break;
            }
            
            const obstacleGeometry = new THREE.BoxGeometry(1.5, height, 1.5);
            const obstacleMaterial = new THREE.MeshStandardMaterial({ 
                color: color,
                emissive: emissive,
                emissiveIntensity: 0.6,
                roughness: 0.3,
                metalness: 0.5
            });
            const obstacle = new THREE.Mesh(obstacleGeometry, obstacleMaterial);
            obstacle.position.set(lanePositions[lane], yPos, z);
            obstacle.castShadow = true;
            obstacle.receiveShadow = true;
            obstacle.userData = { type: type, height: height, yPos: yPos };
            
            // Add glow effect
            const glowGeometry = new THREE.BoxGeometry(1.6, height + 0.1, 1.6);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: emissive,
                transparent: true,
                opacity: 0.3,
                side: THREE.BackSide
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            obstacle.add(glow);
            
            scene.add(obstacle);
            obstacles.push(obstacle);
        }
        
        function createParticleExplosion(x, y, z, color = 0xff6b6b) {
            for (let i = 0; i < 20; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                const particleMaterial = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 1
                });
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                particle.position.set(x, y, z);
                particle.userData = {
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.3,
                        Math.random() * 0.3,
                        (Math.random() - 0.5) * 0.3
                    ),
                    life: 1.0,
                    decay: 0.02
                };
                particles.push(particle);
                scene.add(particle);
            }
        }
        
        function setupControls() {
            // Keyboard controls
            window.addEventListener('keydown', (e) => {
                if (!gameStarted || gameOver) return;
                
                switch(e.key) {
                    case 'ArrowLeft':
                    case 'a':
                    case 'A':
                        moveLeft();
                        break;
                    case 'ArrowRight':
                    case 'd':
                    case 'D':
                        moveRight();
                        break;
                    case 'ArrowUp':
                    case 'w':
                    case 'W':
                    case ' ':
                        jump();
                        break;
                    case 'ArrowDown':
                    case 's':
                    case 'S':
                        slide();
                        break;
                }
            });
            
            // Touch controls
            const container = document.getElementById('game-container');
            
            // Prevent context menu on long press
            container.addEventListener('contextmenu', (e) => {
                e.preventDefault();
            });
            
            container.addEventListener('touchstart', (e) => {
                if (!gameStarted || gameOver) {
                    e.preventDefault();
                    return;
                }
                e.preventDefault();
                e.stopPropagation();
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
            }, { passive: false });
            
            container.addEventListener('touchmove', (e) => {
                if (!gameStarted || gameOver) return;
                e.preventDefault();
            }, { passive: false });
            
            container.addEventListener('touchend', (e) => {
                if (!gameStarted || gameOver) {
                    e.preventDefault();
                    return;
                }
                e.preventDefault();
                e.stopPropagation();
                if (e.changedTouches && e.changedTouches.length > 0) {
                    touchEndX = e.changedTouches[0].clientX;
                    touchEndY = e.changedTouches[0].clientY;
                    handleSwipe();
                }
            }, { passive: false });
            
            container.addEventListener('touchcancel', (e) => {
                e.preventDefault();
            }, { passive: false });
            
            // Mouse controls (for desktop)
            container.addEventListener('mousedown', (e) => {
                if (!gameStarted || gameOver) return;
                touchStartX = e.clientX;
                touchStartY = e.clientY;
            });
            
            container.addEventListener('mouseup', (e) => {
                if (!gameStarted || gameOver) return;
                touchEndX = e.clientX;
                touchEndY = e.clientY;
                handleSwipe();
            });
        }
        
        function handleSwipe() {
            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;
            const minSwipeDistance = 30;
            const maxSwipeTime = 300; // milliseconds
            
            // Calculate swipe distance
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            
            if (distance < minSwipeDistance) {
                // Tap - could be used for jump as default action
                if (!isJumping && !isSliding) {
                    jump();
                }
                return;
            }
            
            // Determine swipe direction
            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                // Horizontal swipe
                if (Math.abs(deltaX) > minSwipeDistance) {
                    if (deltaX > 0) {
                        moveRight();
                    } else {
                        moveLeft();
                    }
                }
            } else {
                // Vertical swipe
                if (Math.abs(deltaY) > minSwipeDistance) {
                    if (deltaY < 0) {
                        jump();
                    } else {
                        slide();
                    }
                }
            }
        }
        
        function showActionFeedback(text, type = '') {
            const feedback = document.getElementById('action-feedback');
            if (feedback) {
                feedback.textContent = text;
                feedback.className = `action-feedback ${type} show`;
                setTimeout(() => {
                    if (feedback) {
                        feedback.classList.remove('show');
                    }
                }, 300);
            }
        }
        
        function moveLeft() {
            if (currentLane > 0) {
                currentLane--;
                showActionFeedback('←', '');
            }
        }
        
        function moveRight() {
            if (currentLane < 2) {
                currentLane++;
                showActionFeedback('→', '');
            }
        }
        
        function jump() {
            if (!isJumping && !isSliding) {
                isJumping = true;
                jumpVelocity = 0.15;
                showActionFeedback('JUMP!', 'jump');
                const baseY = bulkModel?.userData?.baseY || bulkBaseY || groundY;
                createParticleExplosion(bulkModel ? bulkModel.position.x : 0, baseY + 0.5, bulkModel ? bulkModel.position.z : 0, 0x9b30ff);
                cameraShake.intensity = 0.1;
            }
        }
        
        function slide() {
            if (!isSliding && !isJumping) {
                isSliding = true;
                showActionFeedback('SLIDE!', 'slide');
                const baseY = bulkModel?.userData?.baseY || bulkBaseY || groundY;
                createParticleExplosion(bulkModel ? bulkModel.position.x : 0, baseY, bulkModel ? bulkModel.position.z : 0, 0xff6b6b);
                setTimeout(() => {
                    isSliding = false;
                }, 500);
            }
        }
        
        function updateGame() {
            if (!gameStarted || gameOver) return;
            
            const deltaTime = 0.016; // Approximate frame time
            
            // Update distance and score with combo multiplier
            const comboMultiplier = 1 + (combo * 0.1);
            distance += speed * 10 * comboMultiplier;
            score = Math.floor(distance);
            
            // Update UI with animation
            const scoreEl = document.getElementById('score');
            if (scoreEl) {
                scoreEl.textContent = `SCORE: ${score}`;
                if (score % 100 === 0 && score > 0) {
                    scoreEl.classList.add('pulse');
                    setTimeout(() => {
                        if (scoreEl) scoreEl.classList.remove('pulse');
                    }, 200);
                }
            }
            
            const distanceEl = document.getElementById('distance');
            if (distanceEl) {
                distanceEl.textContent = `DISTANCE: ${Math.floor(distance)}m`;
            }
            
            // Update speed indicator
            const speedEl = document.getElementById('speed-indicator');
            if (speedEl) {
                const speedMultiplier = (speed / baseSpeed).toFixed(1);
                speedEl.textContent = `SPEED: ${speedMultiplier}x`;
            }
            
            // Increase speed over time (capped)
            speed = Math.min(baseSpeed + (distance / 1000) * 0.1, baseSpeed * 3);
            
            // Update combo timer
            if (Date.now() - lastComboTime > 2000) {
                combo = 0;
            }
            
            // Update camera shake
            if (cameraShake.intensity > 0) {
                cameraShake.x = (Math.random() - 0.5) * cameraShake.intensity;
                cameraShake.y = (Math.random() - 0.5) * cameraShake.intensity;
                cameraShake.intensity *= 0.9;
                if (cameraShake.intensity < 0.01) {
                    cameraShake.intensity = 0;
                }
            }
            
            // Update Bulk model position
            if (bulkModel) {
                // Smooth lane transition with easing
                const targetX = lanePositions[currentLane];
                const diff = targetX - bulkModel.position.x;
                bulkModel.position.x += diff * 0.15;
                
                // Add slight rotation when changing lanes
                bulkModel.rotation.z = -diff * 0.1;
                
                // Get base Y from userData if available, otherwise use bulkBaseY
                const baseY = bulkModel.userData?.baseY || bulkBaseY || groundY;
                
                // Jump physics
                if (isJumping) {
                    jumpVelocity += gravity;
                    bulkModel.position.y += jumpVelocity;
                    bulkModel.rotation.x = Math.sin(Date.now() * 0.01) * 0.1;
                    if (bulkModel.position.y <= baseY) {
                        bulkModel.position.y = baseY;
                        isJumping = false;
                        jumpVelocity = 0;
                        bulkModel.rotation.x = 0;
                        createParticleExplosion(bulkModel.position.x, baseY, bulkModel.position.z, 0xffd93d);
                    }
                } else if (!isSliding) {
                    bulkModel.position.y = baseY;
                    bulkModel.rotation.x = 0;
                }
                
                // Slide animation - use position offset instead of scale to preserve model proportions
                if (isSliding) {
                    // Don't scale the model, just lower it and rotate
                    bulkModel.position.y = baseY - 0.8;
                    bulkModel.rotation.x = Math.PI / 6;
                } else {
                    if (!isJumping) {
                        bulkModel.position.y = baseY;
                    }
                    bulkModel.rotation.x = 0;
                }
                
                // Running animation (bob) - only when not jumping or sliding
                if (!isJumping && !isSliding) {
                    bulkModel.position.y = baseY + Math.sin(Date.now() * 0.02) * 0.1;
                }
            }
            
            // Update particles
            particles.forEach((particle, index) => {
                particle.position.add(particle.userData.velocity);
                particle.userData.velocity.y -= 0.01; // gravity
                particle.userData.life -= particle.userData.decay;
                particle.material.opacity = particle.userData.life;
                particle.scale.multiplyScalar(0.98);
                
                if (particle.userData.life <= 0) {
                    scene.remove(particle);
                    particles.splice(index, 1);
                }
            });
            
            // Update particle system
            if (particleSystem && particleSystem.geometry && particleSystem.geometry.attributes && particleSystem.geometry.attributes.position) {
                try {
                    const positions = particleSystem.geometry.attributes.position.array;
                    for (let i = 0; i < positions.length; i += 3) {
                        positions[i + 2] += speed * 0.5;
                        if (positions[i + 2] > 20) {
                            positions[i + 2] -= 200;
                            positions[i] = (Math.random() - 0.5) * 20;
                            positions[i + 1] = Math.random() * 10;
                        }
                    }
                    particleSystem.geometry.attributes.position.needsUpdate = true;
                } catch (e) {
                    // Particle system update failed, disable it
                    particleSystem = null;
                }
            }
            
            // Move obstacles towards camera (decreasing Z)
            obstacles.forEach((obstacle, index) => {
                obstacle.position.z -= speed; // Move towards camera
                
                // Animate obstacle (pulse)
                const scale = 1 + Math.sin(Date.now() * 0.005 + obstacle.position.z) * 0.1;
                obstacle.scale.set(scale, scale, scale);
                
                // Check collision
                if (bulkModel) {
                    const distanceX = Math.abs(obstacle.position.x - bulkModel.position.x);
                    const distanceZ = Math.abs(obstacle.position.z - bulkModel.position.z);
                    const distanceY = Math.abs(obstacle.position.y - bulkModel.position.y);
                    
                    if (distanceX < 1.2 && distanceZ < 1.5) {
                        const obstacleHeight = obstacle.userData.height || 2;
                        const obstacleY = obstacle.userData.yPos || 1;
                        
                        // Check if jumping over or sliding under
                        if (isJumping && obstacleHeight < 2 && obstacleY < 1.5) {
                            // Successfully jumped over!
                            combo++;
                            lastComboTime = Date.now();
                            createParticleExplosion(obstacle.position.x, obstacle.position.y, obstacle.position.z, 0xffd93d);
                            scene.remove(obstacle);
                            obstacles.splice(index, 1);
                            return;
                        } else if (isSliding && obstacleHeight > 2 && obstacleY > 1.2) {
                            // Successfully slid under!
                            combo++;
                            lastComboTime = Date.now();
                            createParticleExplosion(obstacle.position.x, obstacle.position.y, obstacle.position.z, 0xffd93d);
                            scene.remove(obstacle);
                            obstacles.splice(index, 1);
                            return;
                        } else if (!isJumping && !isSliding) {
                            // Collision!
                            createParticleExplosion(bulkModel.position.x, bulkModel.position.y, bulkModel.position.z, 0xff0000);
                            cameraShake.intensity = 0.5;
                            endGame();
                            return;
                        }
                    }
                }
                
                // Remove obstacles that are behind camera
                if (obstacle.position.z < -20) {
                    scene.remove(obstacle);
                    obstacles.splice(index, 1);
                }
            });
            
            // Move track segments towards camera (decreasing Z)
            trackSegments.forEach((segment) => {
                if (segment && segment.position) {
                    segment.position.z -= speed; // Move towards camera (negative direction)
                    // Wrap around when segment goes too far behind camera
                    if (segment.position.z < -50) {
                        segment.position.z += 200;
                    }
                }
            });
            
            // Also move lane markers
            scene.children.forEach((child) => {
                if (child.userData && child.userData.originalZ !== undefined) {
                    child.position.z -= speed;
                    if (child.position.z < -50) {
                        child.position.z += 200;
                    }
                }
            });
            
            // Track player Z position (use model position or track distance)
            const playerZ = bulkModel ? bulkModel.position.z : (distance * 0.1);
            
            // Create new obstacles ahead of player
            if (playerZ - lastObstacleZ < -15) {
                const lane = Math.floor(Math.random() * 3);
                createObstacle(lane, playerZ + 30); // Spawn ahead (positive Z)
                lastObstacleZ = playerZ;
            }
            
            // Create new track segments ahead
            if (playerZ - lastTrackZ > -50) {
                createTrackSegment(lastTrackZ + 10);
                lastTrackZ += 10;
            }
            
            // Update camera to follow player with shake
            const playerX = bulkModel ? bulkModel.position.x : lanePositions[currentLane];
            const playerY = bulkModel ? (bulkModel.position.y + 1) : 1;
            const targetX = playerX + cameraShake.x;
            const targetY = 3 + cameraShake.y;
            const targetZ = playerZ + 8;
            
            camera.position.x += (targetX - camera.position.x) * 0.1;
            camera.position.y += (targetY - camera.position.y) * 0.1;
            camera.position.z += (targetZ - camera.position.z) * 0.1;
            
            // Camera looks slightly ahead
            camera.lookAt(playerX, playerY, playerZ + 5);
            
            // Update track markers animation
            trackSegments.forEach((segment) => {
                if (segment.material && segment.material.emissive) {
                    const intensity = 0.5 + Math.sin(Date.now() * 0.005 + segment.position.z) * 0.3;
                    segment.material.emissiveIntensity = intensity;
                }
            });
        }
        
        function endGame() {
            if (gameOver) return; // Prevent multiple calls
            gameOver = true;
            
            // Final camera shake
            cameraShake.intensity = 0.3;
            
            // Show game over after brief delay
            setTimeout(() => {
                document.getElementById('final-score').textContent = `FINAL SCORE: ${score}`;
                document.getElementById('game-over').classList.add('show');
            }, 500);
        }
        
        let lastTime = performance.now();
        
        function animate() {
            requestAnimationFrame(animate);
            
            const currentTime = performance.now();
            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;
            
            // Clamp deltaTime to prevent large jumps
            const clampedDelta = Math.min(deltaTime, 0.033);
            
            if (bulkMixer) {
                bulkMixer.update(clampedDelta);
            }
            
            updateGame();
            renderer.render(scene, camera);
        }
        
        // Game control functions
        window.startGame = function() {
            // Make sure game is initialized
            if (!gameInitialized) {
                initializeGameScene();
                // Wait a bit for initialization
                setTimeout(() => {
                    if (gameInitialized) {
                        document.getElementById('title-screen').classList.add('hidden');
                        gameStarted = true;
                        console.log('Game started! Model:', bulkModel ? 'loaded' : 'placeholder');
                    }
                }, 500);
            } else {
                document.getElementById('title-screen').classList.add('hidden');
                gameStarted = true;
                console.log('Game started! Model:', bulkModel ? 'loaded' : 'placeholder');
            }
        };
        
        window.restartGame = function() {
            location.reload();
        };
        
        // Handle window resize and orientation change
        function handleResize() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            
            const pixelRatio = Math.min(window.devicePixelRatio, 2);
            renderer.setPixelRatio(pixelRatio);
            renderer.setSize(width, height);
        }
        
        window.addEventListener('resize', handleResize);
        window.addEventListener('orientationchange', () => {
            // Delay to allow orientation change to complete
            setTimeout(handleResize, 100);
        });
        
        // Prevent zoom on double tap (iOS)
        let lastTouchEnd = 0;
        document.addEventListener('touchend', (e) => {
            const now = Date.now();
            if (now - lastTouchEnd <= 300) {
                e.preventDefault();
            }
            lastTouchEnd = now;
        }, false);
        
        // WebGL diagnostics function
        function getWebGLDiagnostics() {
            const diagnostics = {
                webglSupported: false,
                webgl2Supported: false,
                vendor: 'Unknown',
                renderer: 'Unknown',
                error: null
            };
            
            try {
                const canvas = document.createElement('canvas');
                
                // Check WebGL 2
                const gl2 = canvas.getContext('webgl2');
                if (gl2) {
                    diagnostics.webgl2Supported = true;
                    diagnostics.webglSupported = true;
                    const debugInfo = gl2.getExtension('WEBGL_debug_renderer_info');
                    if (debugInfo) {
                        diagnostics.vendor = gl2.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) || 'Unknown';
                        diagnostics.renderer = gl2.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) || 'Unknown';
                    }
                } else {
                    // Check WebGL 1
                    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                    if (gl) {
                        diagnostics.webglSupported = true;
                        const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                        if (debugInfo) {
                            diagnostics.vendor = gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) || 'Unknown';
                            diagnostics.renderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) || 'Unknown';
                        }
                    }
                }
            } catch (e) {
                diagnostics.error = e.message;
            }
            
            return diagnostics;
        }
        
        // Initialize game scene only (not start game)
        // Game will start when user clicks "START RUNNING"
        let gameInitialized = false;
        
        function initializeGameScene() {
            if (gameInitialized) return;
            
            try {
                init();
                gameInitialized = true;
            } catch (error) {
                console.error('Initialization error:', error);
                // Show error message on title screen
                const titleScreen = document.getElementById('title-screen');
                if (titleScreen) {
                    let errorMessage = error.message || 'Unknown error. Please refresh the page.';
                    let helpText = '';
                    let diagnostics = '';
                    
                    // Provide specific help based on error type
                    if (error.message && error.message.includes('WebGL')) {
                        const webglDiag = getWebGLDiagnostics();
                        diagnostics = `
                            <div style="color: #9b30ff; font-size: 0.5rem; margin-top: 15px; line-height: 1.8; text-align: left; max-width: 500px; padding: 0 20px;">
                                <strong>WebGL Diagnostics:</strong><br>
                                WebGL Supported: ${webglDiag.webglSupported ? 'Yes' : 'No'}<br>
                                WebGL 2.0: ${webglDiag.webgl2Supported ? 'Yes' : 'No'}<br>
                                Vendor: ${webglDiag.vendor}<br>
                                Renderer: ${webglDiag.renderer}<br>
                                ${webglDiag.error ? `Error: ${webglDiag.error}` : ''}
                            </div>
                        `;
                        
                        helpText = `
                            <div style="color: #ffd93d; font-size: 0.5rem; margin-top: 15px; line-height: 1.8;">
                                <strong>TIPS TO FIX:</strong><br>
                                • Update your browser to the latest version<br>
                                • Update your graphics drivers<br>
                                • Try a different browser (Chrome, Firefox, Edge)<br>
                                • Enable hardware acceleration in browser settings<br>
                                • Check if WebGL is blocked by browser extensions<br>
                                • Try disabling browser extensions temporarily
                            </div>
                        `;
                    }
                    
                    titleScreen.innerHTML = `
                        <div class="title-main">BULK RUNNER</div>
                        <div class="subtitle" style="color: #ff6b6b; margin-top: 20px;">
                            Error loading game
                        </div>
                        <div style="color: #fff; font-size: 0.6rem; margin-top: 20px; max-width: 500px; padding: 0 20px; line-height: 1.8;">
                            ${errorMessage}
                        </div>
                        ${diagnostics}
                        ${helpText}
                        <button class="start-btn" onclick="location.reload()" style="margin-top: 30px;">RELOAD PAGE</button>
                    `;
                }
            }
        }
        
        // Initialize when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeGameScene);
        } else {
            // DOM already loaded
            setTimeout(initializeGameScene, 100);
        }
    </script>
</body>
</html>

