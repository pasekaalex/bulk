<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>BULK RUNNER - Infinite Runner</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Bangers&family=Press+Start+2P&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            background: #000;
            overflow: hidden;
            font-family: 'Press Start 2P', monospace;
            touch-action: none;
        }
        
        #game-container { 
            width: 100vw; 
            height: 100vh; 
            position: relative;
        }
        
        canvas { display: block; }
        
        #title-screen {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(135deg, #2d1b4e 0%, #1a0a2e 50%, #0d0d0d 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }
        
        #title-screen.hidden { display: none; }
        
        .title-main {
            font-family: 'Bangers', cursive;
            font-size: clamp(3rem, 10vw, 6rem);
            color: #9b30ff;
            text-shadow: 0 0 20px #ff00ff, 4px 4px 0 #000;
            letter-spacing: 0.1em;
            animation: pulse 0.5s ease-in-out infinite alternate;
        }
        
        @keyframes pulse { from { transform: scale(1); } to { transform: scale(1.05); } }
        
        .subtitle {
            font-size: clamp(0.8rem, 2vw, 1.2rem);
            color: #ffd93d;
            margin-top: 20px;
        }
        
        .instructions {
            font-size: 0.6rem;
            color: #fff;
            margin-top: 30px;
            text-align: center;
            line-height: 2;
        }
        
        .start-btn {
            margin-top: 40px;
            padding: 20px 60px;
            font-family: 'Bangers', cursive;
            font-size: clamp(1.5rem, 4vw, 2.5rem);
            background: linear-gradient(180deg, #9b30ff 0%, #6b0099 100%);
            color: #fff;
            border: 4px solid #ff00ff;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 0 30px #9b30ff;
            animation: float 1s ease-in-out infinite;
        }
        
        @keyframes float { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-10px); } }
        
        .start-btn:hover { transform: scale(1.1); }
        
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #fff;
            font-size: 14px;
            text-shadow: 2px 2px 0 #000;
            z-index: 50;
        }
        
        #score { font-size: 24px; color: #ffd93d; }
        #money { margin-top: 10px; font-size: 20px; color: #00ff88; }
        #distance { margin-top: 10px; color: #9b30ff; }
        
        #game-over {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
        }
        
        #game-over.show { display: flex; }
        
        .game-over-title {
            font-family: 'Bangers', cursive;
            font-size: clamp(2rem, 6vw, 4rem);
            color: #ff6b6b;
            text-shadow: 0 0 20px #ff0000;
        }
        
        .final-score {
            font-size: clamp(1rem, 3vw, 1.5rem);
            color: #ffd93d;
            margin: 20px 0 10px 0;
        }
        
        .final-money {
            font-size: clamp(1.2rem, 3.5vw, 1.8rem);
            color: #00ff88;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #00ff88;
        }
        
        .restart-btn {
            padding: 15px 40px;
            font-family: 'Bangers', cursive;
            font-size: 1.5rem;
            background: linear-gradient(180deg, #9b30ff 0%, #6b0099 100%);
            color: #fff;
            border: 4px solid #ff00ff;
            border-radius: 10px;
            cursor: pointer;
        }
        
        .back-link {
            margin-top: 20px;
            color: #9b30ff;
            text-decoration: none;
            font-size: 0.8rem;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="title-screen">
            <div class="title-main">BULK RUNNER</div>
            <div class="subtitle">INFINITE RUNNER</div>
            <div class="instructions">
                ← → or SWIPE to change lanes<br>
                SPACE or TAP to jump<br>
                Avoid obstacles! Collect drinks!
            </div>
            <button class="start-btn" onclick="startGame()">START</button>
        </div>
        
        <div id="hud" style="display: none;">
            <div id="score">SCORE: 0</div>
            <div id="money">$0</div>
            <div id="distance">0m</div>
        </div>
        
        <div id="game-over">
            <div class="game-over-title">GAME OVER</div>
            <div class="final-score" id="final-score">SCORE: 0</div>
            <div class="final-money" id="final-money">$0</div>
            <button class="restart-btn" onclick="location.reload()">PLAY AGAIN</button>
            <a href="index.html" class="back-link">BACK TO HOME</a>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Load GLTFLoader
        (function() {
            const script = document.createElement('script');
            script.src = 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js';
            script.onload = () => console.log('GLTFLoader loaded');
            document.head.appendChild(script);
        })();
    </script>
    <script>
        // Game variables
        let scene, camera, renderer;
        let bulk, mixer;
        let clock = new THREE.Clock();
        let gameStarted = false, gameOver = false;
        let score = 0, distance = 0;
        let speed = 0.5;
        let currentLane = 1; // 0=left, 1=center, 2=right
        const lanePositions = [-3, 0, 3];
        let obstacles = [];
        let ground = [];
        let drinks = [];
        let money = 0;
        let buildings = [];
        let explosions = [];

        // Jump mechanics
        let isJumping = false;
        let jumpVelocity = 0;
        const gravity = -0.02;
        const jumpStrength = 0.35;
        const groundLevel = 0.2;

        // Touch controls
        let touchStartX = 0, touchStartY = 0;

        // Car spawn prevention
        let lastSpawnTime = {};  // Track last spawn time per lane
        const minSpawnInterval = 1500; // Minimum ms between spawns in same lane
        
        function init() {
            // Scene - night city atmosphere
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a15);
            scene.fog = new THREE.Fog(0x0a0a15, 50, 200);
            
            // Camera - behind and above player
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 10);
            camera.lookAt(0, 2, 0);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('game-container').appendChild(renderer.domElement);
            
            // Lights - city night lighting
            const ambient = new THREE.AmbientLight(0x404060, 0.3);
            scene.add(ambient);
            
            // Main directional light (moonlight)
            const moon = new THREE.DirectionalLight(0x6666aa, 0.5);
            moon.position.set(5, 30, 10);
            moon.castShadow = true;
            scene.add(moon);
            
            // Purple city glow from below
            const cityGlow = new THREE.DirectionalLight(0x9b30ff, 0.4);
            cityGlow.position.set(0, -5, 0);
            scene.add(cityGlow);
            
            // Street light effect (hemisphere)
            const streetLight = new THREE.HemisphereLight(0xffffcc, 0x222233, 0.6);
            scene.add(streetLight);
            
            // Create ground
            createGround();
            
            // Create city buildings
            createCity();
            
            // Create Bulk character
            createBulk();
            
            // Controls
            setupControls();
            
            // Start loop
            animate();
        }
        
        function createGround() {
            // Create repeating ground segments - city street
            for (let i = 0; i < 20; i++) {
                // Main road (dark asphalt)
                const groundGeo = new THREE.PlaneGeometry(12, 20);
                const groundMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a });
                const tile = new THREE.Mesh(groundGeo, groundMat);
                tile.rotation.x = -Math.PI / 2;
                tile.position.z = -i * 20;
                tile.receiveShadow = true;
                scene.add(tile);
                ground.push(tile);
                
                // Sidewalks on both sides
                const sidewalkMat = new THREE.MeshStandardMaterial({ color: 0x3a3a3a });
                const leftSidewalk = new THREE.Mesh(new THREE.PlaneGeometry(4, 20), sidewalkMat);
                leftSidewalk.rotation.x = -Math.PI / 2;
                leftSidewalk.position.set(-8, 0.05, -i * 20);
                scene.add(leftSidewalk);
                ground.push(leftSidewalk);
                
                const rightSidewalk = new THREE.Mesh(new THREE.PlaneGeometry(4, 20), sidewalkMat);
                rightSidewalk.rotation.x = -Math.PI / 2;
                rightSidewalk.position.set(8, 0.05, -i * 20);
                scene.add(rightSidewalk);
                ground.push(rightSidewalk);
                
                // Lane markers (white road lines)
                for (let lane = 0; lane < 3; lane++) {
                    const marker = new THREE.Mesh(
                        new THREE.PlaneGeometry(0.3, 3),
                        new THREE.MeshStandardMaterial({ color: 0xffffff })
                    );
                    marker.rotation.x = -Math.PI / 2;
                    marker.position.set(lanePositions[lane], 0.02, -i * 20);
                    scene.add(marker);
                    ground.push(marker);
                }
                
                // Yellow center line
                const centerLine = new THREE.Mesh(
                    new THREE.PlaneGeometry(0.2, 20),
                    new THREE.MeshStandardMaterial({ color: 0xffcc00 })
                );
                centerLine.rotation.x = -Math.PI / 2;
                centerLine.position.set(0, 0.02, -i * 20);
                scene.add(centerLine);
                ground.push(centerLine);
            }
        }
        
        function createCity() {
            // Building colors - various city building tones
            const buildingColors = [
                0x2a2a3a, 0x3a3a4a, 0x252535, 0x1a1a2a, 0x353545,
                0x404050, 0x2f2f3f, 0x454555
            ];
            
            // Window color (lit windows at night)
            const windowColor = 0xffffaa;
            
            // Create buildings on both sides
            for (let i = 0; i < 30; i++) {
                // Left side buildings
                createBuilding(-12 - Math.random() * 5, -i * 15, buildingColors, windowColor);
                
                // Right side buildings
                createBuilding(12 + Math.random() * 5, -i * 15, buildingColors, windowColor);
            }
        }
        
        function createBuilding(x, z, colors, windowColor) {
            const building = new THREE.Group();
            
            // Random building dimensions
            const width = 4 + Math.random() * 6;
            const height = 15 + Math.random() * 40;
            const depth = 4 + Math.random() * 6;
            
            // Main building body
            const bodyGeo = new THREE.BoxGeometry(width, height, depth);
            const bodyMat = new THREE.MeshStandardMaterial({ 
                color: colors[Math.floor(Math.random() * colors.length)]
            });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = height / 2;
            body.castShadow = true;
            body.receiveShadow = true;
            building.add(body);
            
            // Add windows (emissive rectangles)
            const windowMat = new THREE.MeshStandardMaterial({ 
                color: windowColor,
                emissive: windowColor,
                emissiveIntensity: 0.5 + Math.random() * 0.5
            });
            
            const windowRows = Math.floor(height / 3);
            const windowCols = Math.floor(width / 1.5);
            
            for (let row = 0; row < windowRows; row++) {
                for (let col = 0; col < windowCols; col++) {
                    // Randomly skip some windows (lights off)
                    if (Math.random() > 0.7) continue;
                    
                    const windowGeo = new THREE.PlaneGeometry(0.8, 1.2);
                    const windowMesh = new THREE.Mesh(windowGeo, windowMat);
                    
                    // Position on front face
                    const wx = -width/2 + 1 + col * 1.5;
                    const wy = 2 + row * 3;
                    windowMesh.position.set(wx, wy, depth/2 + 0.01);
                    building.add(windowMesh);
                    
                    // Position on back face
                    const windowBack = windowMesh.clone();
                    windowBack.position.z = -depth/2 - 0.01;
                    windowBack.rotation.y = Math.PI;
                    building.add(windowBack);
                }
            }
            
            // Rooftop details (random)
            if (Math.random() > 0.5) {
                // AC unit or water tower
                const roofGeo = new THREE.BoxGeometry(1.5, 2, 1.5);
                const roofMat = new THREE.MeshStandardMaterial({ color: 0x555555 });
                const roofDetail = new THREE.Mesh(roofGeo, roofMat);
                roofDetail.position.set(
                    (Math.random() - 0.5) * width * 0.5,
                    height + 1,
                    (Math.random() - 0.5) * depth * 0.5
                );
                building.add(roofDetail);
            }
            
            // Antenna on some tall buildings
            if (height > 35 && Math.random() > 0.5) {
                const antennaGeo = new THREE.CylinderGeometry(0.1, 0.1, 8, 8);
                const antennaMat = new THREE.MeshStandardMaterial({ color: 0x888888 });
                const antenna = new THREE.Mesh(antennaGeo, antennaMat);
                antenna.position.y = height + 4;
                building.add(antenna);
                
                // Blinking light
                const lightGeo = new THREE.SphereGeometry(0.2, 8, 8);
                const lightMat = new THREE.MeshStandardMaterial({ 
                    color: 0xff0000,
                    emissive: 0xff0000,
                    emissiveIntensity: 1
                });
                const light = new THREE.Mesh(lightGeo, lightMat);
                light.position.y = height + 8;
                building.add(light);
            }
            
            building.position.set(x, 0, z);
            scene.add(building);
            buildings.push(building);
        }
        
        function createBulk() {
            bulk = new THREE.Group();
            bulk.position.set(0, 0, 0);
            scene.add(bulk);
            
            // Try to load GLB model
            function tryLoadModel(attempts) {
                if (typeof THREE.GLTFLoader === 'undefined') {
                    if (attempts < 30) {
                        setTimeout(() => tryLoadModel(attempts + 1), 100);
                        return;
                    }
                    console.log('GLTFLoader not available, using fallback');
                    createFallbackBulk();
                    return;
                }
                
                const loader = new THREE.GLTFLoader();
                loader.load('run.glb',
                    (gltf) => {
                        console.log('GLB loaded!');
                        console.log('Animations:', gltf.animations.length);
                        if (gltf.animations.length > 0) {
                            console.log('Animation names:', gltf.animations.map(a => a.name));
                        }
                        const model = gltf.scene;

                        // Scale based on bounding box
                        const box = new THREE.Box3().setFromObject(model);
                        const size = box.getSize(new THREE.Vector3());
                        const maxDim = Math.max(size.x, size.y, size.z);
                        const scale = 4 / maxDim;
                        model.scale.set(scale, scale, scale);

                        // Center and position
                        const center = box.getCenter(new THREE.Vector3());
                        model.position.set(-center.x * scale, -box.min.y * scale * 1.1, -center.z * scale);

                        // Rotate 180 degrees to face forward
                        model.rotation.y = Math.PI;

                        // Enable shadows
                        model.traverse(child => {
                            if (child.isMesh) {
                                child.castShadow = true;
                                child.receiveShadow = true;
                            }
                        });

                        // Setup animations if they exist
                        if (gltf.animations && gltf.animations.length > 0) {
                            mixer = new THREE.AnimationMixer(model);
                            gltf.animations.forEach((clip, i) => {
                                const action = mixer.clipAction(clip);
                                action.play();
                                console.log(`Playing animation ${i}: ${clip.name}`);
                            });
                        }

                        bulk.add(model);
                    },
                    undefined,
                    (error) => {
                        console.log('GLB failed, using fallback. Error:', error);
                        createFallbackBulk();
                    }
                );
            }
            
            tryLoadModel(0);
        }
        
        function createFallbackBulk() {
            // Simple purple hulk made of boxes
            const mat = new THREE.MeshStandardMaterial({ color: 0x9b30ff, emissive: 0x4a0080, emissiveIntensity: 0.3 });
            
            // Create a container for the model parts so we can rotate it
            const modelContainer = new THREE.Group();
            
            // Body (Y raised 10%: 2 * 1.1 = 2.2)
            const body = new THREE.Mesh(new THREE.BoxGeometry(1.5, 2, 1), mat);
            body.position.y = 2.2;
            body.castShadow = true;
            modelContainer.add(body);
            
            // Head (Y raised 10%: 3.5 * 1.1 = 3.85)
            const head = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), mat);
            head.position.y = 3.85;
            head.castShadow = true;
            modelContainer.add(head);
            
            // Arms (Y raised 10%: 2 * 1.1 = 2.2)
            const armL = new THREE.Mesh(new THREE.BoxGeometry(0.5, 1.5, 0.5), mat);
            armL.position.set(-1.2, 2.2, 0);
            armL.castShadow = true;
            modelContainer.add(armL);
            
            const armR = armL.clone();
            armR.position.x = 1.2;
            modelContainer.add(armR);
            
            // Legs (Y raised 10%: 0.6 * 1.1 = 0.66)
            const legL = new THREE.Mesh(new THREE.BoxGeometry(0.6, 1.2, 0.6), mat);
            legL.position.set(-0.4, 0.66, 0);
            legL.castShadow = true;
            modelContainer.add(legL);
            
            const legR = legL.clone();
            legR.position.x = 0.4;
            modelContainer.add(legR);
            
            // Rotate 180 degrees to face forward
            modelContainer.rotation.y = Math.PI;
            
            bulk.add(modelContainer);
        }
        
        function createObstacle() {
            // Pick a lane, but avoid lanes that spawned recently
            const now = Date.now();
            const availableLanes = [];

            for (let i = 0; i < 3; i++) {
                const timeSinceLastSpawn = now - (lastSpawnTime[i] || 0);
                if (timeSinceLastSpawn > minSpawnInterval) {
                    availableLanes.push(i);
                }
            }

            // If no lanes available (all spawned recently), skip this spawn
            if (availableLanes.length === 0) return;

            // Pick random available lane
            const lane = availableLanes[Math.floor(Math.random() * availableLanes.length)];
            lastSpawnTime[lane] = now;

            const car = new THREE.Group();
            
            // Random car colors
            const carColors = [0xff3333, 0x3333ff, 0x33ff33, 0xffff33, 0xff9900, 0x00ffff, 0xff00ff, 0xffffff];
            const carColor = carColors[Math.floor(Math.random() * carColors.length)];
            const carMat = new THREE.MeshStandardMaterial({ color: carColor, metalness: 0.8, roughness: 0.3 });
            const darkMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
            const glassMat = new THREE.MeshStandardMaterial({ color: 0x88ccff, transparent: true, opacity: 0.6 });
            
            // Car body (main)
            const bodyGeo = new THREE.BoxGeometry(2, 1, 4);
            const body = new THREE.Mesh(bodyGeo, carMat);
            body.position.y = 0.7;
            body.castShadow = true;
            car.add(body);
            
            // Car roof/cabin
            const cabinGeo = new THREE.BoxGeometry(1.8, 0.8, 2);
            const cabin = new THREE.Mesh(cabinGeo, carMat);
            cabin.position.set(0, 1.5, -0.3);
            cabin.castShadow = true;
            car.add(cabin);
            
            // Windshield
            const windshieldGeo = new THREE.PlaneGeometry(1.6, 0.7);
            const windshield = new THREE.Mesh(windshieldGeo, glassMat);
            windshield.position.set(0, 1.5, 0.75);
            windshield.rotation.x = -0.3;
            car.add(windshield);
            
            // Rear window
            const rearWindow = new THREE.Mesh(windshieldGeo, glassMat);
            rearWindow.position.set(0, 1.5, -1.35);
            rearWindow.rotation.x = 0.3;
            rearWindow.rotation.y = Math.PI;
            car.add(rearWindow);
            
            // Wheels
            const wheelGeo = new THREE.CylinderGeometry(0.4, 0.4, 0.3, 16);
            const wheelPositions = [
                [-1, 0.4, 1.2], [1, 0.4, 1.2],
                [-1, 0.4, -1.2], [1, 0.4, -1.2]
            ];
            wheelPositions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeo, darkMat);
                wheel.rotation.z = Math.PI / 2;
                wheel.position.set(pos[0], pos[1], pos[2]);
                wheel.castShadow = true;
                car.add(wheel);
            });
            
            // Headlights
            const lightGeo = new THREE.BoxGeometry(0.3, 0.2, 0.1);
            const lightMat = new THREE.MeshStandardMaterial({ color: 0xffffaa, emissive: 0xffffaa, emissiveIntensity: 0.8 });
            const headlightL = new THREE.Mesh(lightGeo, lightMat);
            headlightL.position.set(-0.6, 0.7, 2);
            car.add(headlightL);
            const headlightR = headlightL.clone();
            headlightR.position.x = 0.6;
            car.add(headlightR);
            
            // Taillights
            const tailMat = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0xff0000, emissiveIntensity: 0.5 });
            const taillightL = new THREE.Mesh(lightGeo, tailMat);
            taillightL.position.set(-0.6, 0.7, -2);
            car.add(taillightL);
            const taillightR = taillightL.clone();
            taillightR.position.x = 0.6;
            car.add(taillightR);
            
            car.position.set(lanePositions[lane], 0, -200);
            car.userData.lane = lane;
            scene.add(car);
            obstacles.push(car);
        }
        
        function createExplosion(x, y, z) {
            const explosion = new THREE.Group();
            explosion.position.set(x, y, z);
            
            // Create explosion particles
            const particleCount = 30;
            for (let i = 0; i < particleCount; i++) {
                const size = 0.3 + Math.random() * 0.5;
                const geo = new THREE.SphereGeometry(size, 8, 8);
                const colors = [0xff4400, 0xff8800, 0xffcc00, 0xff0000, 0xffff00];
                const mat = new THREE.MeshStandardMaterial({ 
                    color: colors[Math.floor(Math.random() * colors.length)],
                    emissive: colors[Math.floor(Math.random() * colors.length)],
                    emissiveIntensity: 2
                });
                const particle = new THREE.Mesh(geo, mat);
                
                // Random direction
                particle.userData.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.5,
                    Math.random() * 0.3 + 0.1,
                    (Math.random() - 0.5) * 0.5
                );
                particle.userData.life = 1;
                explosion.add(particle);
            }
            
            // Add debris (car parts)
            for (let i = 0; i < 10; i++) {
                const debrisGeo = new THREE.BoxGeometry(
                    0.2 + Math.random() * 0.4,
                    0.1 + Math.random() * 0.2,
                    0.2 + Math.random() * 0.4
                );
                const debrisMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
                const debris = new THREE.Mesh(debrisGeo, debrisMat);
                debris.userData.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.4,
                    Math.random() * 0.4 + 0.2,
                    (Math.random() - 0.5) * 0.4
                );
                debris.userData.rotSpeed = new THREE.Vector3(
                    Math.random() * 0.3,
                    Math.random() * 0.3,
                    Math.random() * 0.3
                );
                debris.userData.life = 1;
                explosion.add(debris);
            }
            
            // Flash light
            const flashLight = new THREE.PointLight(0xff8800, 5, 20);
            explosion.add(flashLight);
            explosion.userData.flashLight = flashLight;
            explosion.userData.age = 0;
            
            scene.add(explosion);
            explosions.push(explosion);
        }
        
        function createDrink() {
            const lane = Math.floor(Math.random() * 3);
            const drink = new THREE.Group();
            
            // Bottle body (cylinder)
            const bottleGeo = new THREE.CylinderGeometry(0.3, 0.4, 1.2, 8);
            const bottleMat = new THREE.MeshStandardMaterial({ 
                color: 0x9b30ff, 
                emissive: 0x6b00ff, 
                emissiveIntensity: 0.8,
                transparent: true,
                opacity: 0.9
            });
            const bottle = new THREE.Mesh(bottleGeo, bottleMat);
            bottle.position.y = 0.6;
            drink.add(bottle);
            
            // Bottle neck
            const neckGeo = new THREE.CylinderGeometry(0.15, 0.25, 0.4, 8);
            const neck = new THREE.Mesh(neckGeo, bottleMat);
            neck.position.y = 1.4;
            drink.add(neck);
            
            // Cap
            const capGeo = new THREE.CylinderGeometry(0.18, 0.18, 0.15, 8);
            const capMat = new THREE.MeshStandardMaterial({ 
                color: 0xffd93d, 
                emissive: 0xffaa00, 
                emissiveIntensity: 0.5 
            });
            const cap = new THREE.Mesh(capGeo, capMat);
            cap.position.y = 1.7;
            drink.add(cap);
            
            // Glowing ring effect
            const ringGeo = new THREE.TorusGeometry(0.6, 0.1, 8, 16);
            const ringMat = new THREE.MeshStandardMaterial({ 
                color: 0xff00ff, 
                emissive: 0xff00ff, 
                emissiveIntensity: 1 
            });
            const ring = new THREE.Mesh(ringGeo, ringMat);
            ring.rotation.x = Math.PI / 2;
            ring.position.y = 0.6;
            drink.add(ring);
            
            drink.position.set(lanePositions[lane], 1, -200);
            drink.userData.lane = lane;
            drink.userData.rotationSpeed = 0.05;
            scene.add(drink);
            drinks.push(drink);
        }
        
        function setupControls() {
            // Keyboard
            window.addEventListener('keydown', (e) => {
                if (!gameStarted || gameOver) return;

                const key = e.key.toLowerCase();

                // A or Left Arrow = move LEFT (decrease lane)
                if (e.key === 'ArrowLeft' || key === 'a') {
                    if (currentLane > 0) currentLane--;
                }
                // D or Right Arrow = move RIGHT (increase lane)
                else if (e.key === 'ArrowRight' || key === 'd') {
                    if (currentLane < 2) currentLane++;
                }
                // Space = JUMP
                else if (e.key === ' ' || key === 'w' || e.key === 'ArrowUp') {
                    if (!isJumping) {
                        isJumping = true;
                        jumpVelocity = jumpStrength;
                    }
                }
            });

            // Touch
            const container = document.getElementById('game-container');

            container.addEventListener('touchstart', (e) => {
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
            });

            container.addEventListener('touchend', (e) => {
                if (!gameStarted || gameOver) return;

                const dx = e.changedTouches[0].clientX - touchStartX;
                const dy = e.changedTouches[0].clientY - touchStartY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (Math.abs(dx) > 30 && distance > 30) {
                    // Horizontal swipe
                    if (dx > 0 && currentLane < 2) currentLane++;
                    else if (dx < 0 && currentLane > 0) currentLane--;
                } else if (distance < 30) {
                    // Tap = JUMP
                    if (!isJumping) {
                        isJumping = true;
                        jumpVelocity = jumpStrength;
                    }
                }
            });
        }
        
        function update() {
            if (!gameStarted || gameOver) return;
            
            // Update score
            distance += speed;
            score = Math.floor(distance);
            document.getElementById('score').textContent = 'SCORE: ' + score;
            document.getElementById('distance').textContent = Math.floor(distance) + 'm';
            
            // Increase speed
            speed = 0.5 + distance * 0.0001;
            
            // Move Bulk to lane
            const targetX = lanePositions[currentLane];
            bulk.position.x += (targetX - bulk.position.x) * 0.2;

            // Jump physics
            if (isJumping) {
                jumpVelocity += gravity;
                bulk.position.y += jumpVelocity;

                // Land on ground
                if (bulk.position.y <= groundLevel) {
                    bulk.position.y = groundLevel;
                    isJumping = false;
                    jumpVelocity = 0;
                }
            } else {
                // Running animation (subtle bob) + raised to prevent feet clipping
                bulk.position.y = groundLevel + Math.sin(Date.now() * 0.02) * 0.05;
            }
            
            // Move ground
            ground.forEach(tile => {
                tile.position.z += speed;
                if (tile.position.z > 20) {
                    tile.position.z -= 400;
                }
            });
            
            // Move buildings
            buildings.forEach(building => {
                building.position.z += speed;
                if (building.position.z > 30) {
                    building.position.z -= 450;
                }
            });
            
            // Spawn obstacles
            if (Math.random() < 0.02) {
                createObstacle();
            }
            
            // Spawn drinks (less frequent than obstacles)
            if (Math.random() < 0.015) {
                createDrink();
            }
            
            // Move and check drinks (pickups)
            for (let i = drinks.length - 1; i >= 0; i--) {
                const drink = drinks[i];
                drink.position.z += speed;
                
                // Rotate and bob the drink
                drink.rotation.y += drink.userData.rotationSpeed;
                drink.position.y = 1 + Math.sin(Date.now() * 0.005 + i) * 0.3;
                
                // Pickup check
                if (drink.position.z > -2 && drink.position.z < 2) {
                    if (Math.abs(bulk.position.x - drink.position.x) < 1.5) {
                        // Picked up!
                        money += 50;
                        document.getElementById('money').textContent = '$' + money;
                        scene.remove(drink);
                        drinks.splice(i, 1);
                        continue;
                    }
                }
                
                // Remove passed drinks
                if (drink.position.z > 10) {
                    scene.remove(drink);
                    drinks.splice(i, 1);
                }
            }
            
            // Move and check obstacles
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obs = obstacles[i];
                obs.position.z += speed;

                // Collision check (lane-based and height-based)
                if (obs.position.z > -2 && obs.position.z < 2) {
                    if (Math.abs(bulk.position.x - obs.position.x) < 2) {
                        // Check if player is jumping high enough to clear the car (car height ~2)
                        const carHeight = 2;
                        if (bulk.position.y < carHeight) {
                            // Hit! Create explosion at car position
                            createExplosion(obs.position.x, obs.position.y + 1, obs.position.z);
                            scene.remove(obs);
                            obstacles.splice(i, 1);
                            // Delay game over so explosion can be seen
                            setTimeout(endGame, 500);
                            gameOver = true; // Stop updates immediately
                            return;
                        }
                    }
                }

                // Remove passed obstacles
                if (obs.position.z > 10) {
                    scene.remove(obs);
                    obstacles.splice(i, 1);
                }
            }
            
            // Camera follows
            camera.position.x += (bulk.position.x - camera.position.x) * 0.1;
        }
        
        function updateExplosions() {
            for (let i = explosions.length - 1; i >= 0; i--) {
                const explosion = explosions[i];
                explosion.userData.age += 0.016;
                
                // Fade out flash light
                if (explosion.userData.flashLight) {
                    explosion.userData.flashLight.intensity = Math.max(0, 5 - explosion.userData.age * 10);
                }
                
                // Update particles
                explosion.children.forEach(child => {
                    if (child.userData.velocity) {
                        child.position.add(child.userData.velocity);
                        child.userData.velocity.y -= 0.01; // Gravity
                        child.userData.life -= 0.02;
                        
                        // Rotation for debris
                        if (child.userData.rotSpeed) {
                            child.rotation.x += child.userData.rotSpeed.x;
                            child.rotation.y += child.userData.rotSpeed.y;
                            child.rotation.z += child.userData.rotSpeed.z;
                        }
                        
                        // Scale down as life decreases
                        const scale = Math.max(0.1, child.userData.life);
                        child.scale.set(scale, scale, scale);
                    }
                });
                
                // Remove old explosions
                if (explosion.userData.age > 2) {
                    scene.remove(explosion);
                    explosions.splice(i, 1);
                }
            }
        }
        
        function animate() {
            requestAnimationFrame(animate);

            // Update animation mixer
            if (mixer) {
                const delta = clock.getDelta();
                mixer.update(delta);
            }

            update();
            updateExplosions(); // Always update explosions even after game over
            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }
        }
        
        function startGame() {
            document.getElementById('title-screen').classList.add('hidden');
            document.getElementById('hud').style.display = 'block';
            gameStarted = true;
        }
        
        function endGame() {
            gameOver = true;
            document.getElementById('final-score').textContent = 'SCORE: ' + score;
            document.getElementById('final-money').textContent = '$' + money;
            document.getElementById('game-over').classList.add('show');
        }
        
        // Handle resize
        window.addEventListener('resize', () => {
            if (camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        });
        
        // Wait for page load then init
        window.addEventListener('load', () => {
            setTimeout(init, 100);
        });
    </script>
</body>
</html>
