<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>BULK RUNNER - Infinite Runner</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Bangers&family=Press+Start+2P&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            background: #000;
            overflow: hidden;
            font-family: 'Press Start 2P', monospace;
            touch-action: none;
        }
        
        #game-container { 
            width: 100vw; 
            height: 100vh; 
            position: relative;
        }
        
        canvas { display: block; }
        
        #title-screen {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(135deg, #2d1b4e 0%, #1a0a2e 50%, #0d0d0d 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }
        
        #title-screen.hidden { display: none; }
        
        .title-main {
            font-family: 'Bangers', cursive;
            font-size: clamp(3rem, 10vw, 6rem);
            color: #9b30ff;
            text-shadow: 0 0 20px #ff00ff, 4px 4px 0 #000;
            letter-spacing: 0.1em;
            animation: pulse 0.5s ease-in-out infinite alternate;
        }
        
        @keyframes pulse { from { transform: scale(1); } to { transform: scale(1.05); } }
        
        .subtitle {
            font-size: clamp(0.8rem, 2vw, 1.2rem);
            color: #ffd93d;
            margin-top: 20px;
        }
        
        .instructions {
            font-size: 0.6rem;
            color: #fff;
            margin-top: 30px;
            text-align: center;
            line-height: 2;
        }
        
        .start-btn {
            margin-top: 40px;
            padding: 20px 60px;
            font-family: 'Bangers', cursive;
            font-size: clamp(1.5rem, 4vw, 2.5rem);
            background: linear-gradient(180deg, #9b30ff 0%, #6b0099 100%);
            color: #fff;
            border: 4px solid #ff00ff;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 0 30px #9b30ff;
            animation: float 1s ease-in-out infinite;
        }
        
        @keyframes float { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-10px); } }
        
        .start-btn:hover { transform: scale(1.1); }
        
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #fff;
            font-size: 14px;
            text-shadow: 2px 2px 0 #000;
            z-index: 50;
        }
        
        #score { font-size: 24px; color: #ffd93d; }
        #distance { margin-top: 10px; color: #9b30ff; }
        
        #game-over {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
        }
        
        #game-over.show { display: flex; }
        
        .game-over-title {
            font-family: 'Bangers', cursive;
            font-size: clamp(2rem, 6vw, 4rem);
            color: #ff6b6b;
            text-shadow: 0 0 20px #ff0000;
        }
        
        .final-score {
            font-size: clamp(1rem, 3vw, 1.5rem);
            color: #ffd93d;
            margin: 20px 0;
        }
        
        .restart-btn {
            padding: 15px 40px;
            font-family: 'Bangers', cursive;
            font-size: 1.5rem;
            background: linear-gradient(180deg, #9b30ff 0%, #6b0099 100%);
            color: #fff;
            border: 4px solid #ff00ff;
            border-radius: 10px;
            cursor: pointer;
        }
        
        .back-link {
            margin-top: 20px;
            color: #9b30ff;
            text-decoration: none;
            font-size: 0.8rem;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="title-screen">
            <div class="title-main">BULK RUNNER</div>
            <div class="subtitle">INFINITE RUNNER</div>
            <div class="instructions">
                ← → or SWIPE to change lanes<br>
                SPACE or TAP to jump<br>
                Avoid obstacles!
            </div>
            <button class="start-btn" onclick="startGame()">START</button>
        </div>
        
        <div id="hud" style="display: none;">
            <div id="score">SCORE: 0</div>
            <div id="distance">0m</div>
        </div>
        
        <div id="game-over">
            <div class="game-over-title">GAME OVER</div>
            <div class="final-score" id="final-score">SCORE: 0</div>
            <button class="restart-btn" onclick="location.reload()">PLAY AGAIN</button>
            <a href="index.html" class="back-link">BACK TO HOME</a>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Load GLTFLoader
        (function() {
            const script = document.createElement('script');
            script.src = 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js';
            script.onload = () => console.log('GLTFLoader loaded');
            document.head.appendChild(script);
        })();
    </script>
    <script>
        // Game variables
        let scene, camera, renderer;
        let bulk;
        let gameStarted = false, gameOver = false;
        let score = 0, distance = 0;
        let speed = 0.5;
        let currentLane = 1; // 0=left, 1=center, 2=right
        const lanePositions = [-3, 0, 3];
        let isJumping = false, jumpVelocity = 0;
        const gravity = -0.03;
        let obstacles = [];
        let ground = [];
        
        // Touch controls
        let touchStartX = 0, touchStartY = 0;
        
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a0a2e);
            scene.fog = new THREE.Fog(0x1a0a2e, 30, 100);
            
            // Camera - behind and above player
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 10);
            camera.lookAt(0, 2, 0);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('game-container').appendChild(renderer.domElement);
            
            // Lights
            const ambient = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambient);
            
            const sun = new THREE.DirectionalLight(0x9b30ff, 1);
            sun.position.set(5, 20, 10);
            sun.castShadow = true;
            scene.add(sun);
            
            // Create ground
            createGround();
            
            // Create Bulk character
            createBulk();
            
            // Controls
            setupControls();
            
            // Start loop
            animate();
        }
        
        function createGround() {
            // Create repeating ground segments
            for (let i = 0; i < 20; i++) {
                // Main ground
                const groundGeo = new THREE.PlaneGeometry(20, 20);
                const groundMat = new THREE.MeshStandardMaterial({ color: 0x2d1b4e });
                const tile = new THREE.Mesh(groundGeo, groundMat);
                tile.rotation.x = -Math.PI / 2;
                tile.position.z = -i * 20;
                tile.receiveShadow = true;
                scene.add(tile);
                ground.push(tile);
                
                // Lane markers
                for (let lane = 0; lane < 3; lane++) {
                    const marker = new THREE.Mesh(
                        new THREE.PlaneGeometry(2, 20),
                        new THREE.MeshStandardMaterial({ color: lane === 1 ? 0x4a1d6e : 0x3d1560 })
                    );
                    marker.rotation.x = -Math.PI / 2;
                    marker.position.set(lanePositions[lane], 0.01, -i * 20);
                    scene.add(marker);
                    ground.push(marker);
                }
            }
        }
        
        function createBulk() {
            bulk = new THREE.Group();
            bulk.position.set(0, 0, 0);
            scene.add(bulk);
            
            // Try to load GLB model
            function tryLoadModel(attempts) {
                if (typeof THREE.GLTFLoader === 'undefined') {
                    if (attempts < 30) {
                        setTimeout(() => tryLoadModel(attempts + 1), 100);
                        return;
                    }
                    console.log('GLTFLoader not available, using fallback');
                    createFallbackBulk();
                    return;
                }
                
                const loader = new THREE.GLTFLoader();
                loader.load('bulk.glb', 
                    (gltf) => {
                        console.log('GLB loaded!');
                        const model = gltf.scene;
                        
                        // Scale based on bounding box
                        const box = new THREE.Box3().setFromObject(model);
                        const size = box.getSize(new THREE.Vector3());
                        const maxDim = Math.max(size.x, size.y, size.z);
                        const scale = 4 / maxDim;
                        model.scale.set(scale, scale, scale);
                        
                        // Center and position
                        const center = box.getCenter(new THREE.Vector3());
                        model.position.set(-center.x * scale, -box.min.y * scale, -center.z * scale);
                        
                        // Enable shadows
                        model.traverse(child => {
                            if (child.isMesh) {
                                child.castShadow = true;
                                child.receiveShadow = true;
                            }
                        });
                        
                        bulk.add(model);
                    },
                    undefined,
                    (error) => {
                        console.log('GLB failed, using fallback');
                        createFallbackBulk();
                    }
                );
            }
            
            tryLoadModel(0);
        }
        
        function createFallbackBulk() {
            // Simple purple hulk made of boxes
            const mat = new THREE.MeshStandardMaterial({ color: 0x9b30ff, emissive: 0x4a0080, emissiveIntensity: 0.3 });
            
            // Body
            const body = new THREE.Mesh(new THREE.BoxGeometry(1.5, 2, 1), mat);
            body.position.y = 2;
            body.castShadow = true;
            bulk.add(body);
            
            // Head
            const head = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), mat);
            head.position.y = 3.5;
            head.castShadow = true;
            bulk.add(head);
            
            // Arms
            const armL = new THREE.Mesh(new THREE.BoxGeometry(0.5, 1.5, 0.5), mat);
            armL.position.set(-1.2, 2, 0);
            armL.castShadow = true;
            bulk.add(armL);
            
            const armR = armL.clone();
            armR.position.x = 1.2;
            bulk.add(armR);
            
            // Legs
            const legL = new THREE.Mesh(new THREE.BoxGeometry(0.6, 1.2, 0.6), mat);
            legL.position.set(-0.4, 0.6, 0);
            legL.castShadow = true;
            bulk.add(legL);
            
            const legR = legL.clone();
            legR.position.x = 0.4;
            bulk.add(legR);
        }
        
        function createObstacle() {
            const lane = Math.floor(Math.random() * 3);
            const geo = new THREE.BoxGeometry(2, 3, 2);
            const mat = new THREE.MeshStandardMaterial({ 
                color: 0xff4444, 
                emissive: 0xff0000, 
                emissiveIntensity: 0.5 
            });
            const obstacle = new THREE.Mesh(geo, mat);
            obstacle.position.set(lanePositions[lane], 1.5, -200);
            obstacle.castShadow = true;
            obstacle.userData.lane = lane;
            scene.add(obstacle);
            obstacles.push(obstacle);
        }
        
        function setupControls() {
            // Keyboard
            window.addEventListener('keydown', (e) => {
                if (!gameStarted || gameOver) return;
                
                if (e.key === 'ArrowLeft' || e.key === 'a') {
                    if (currentLane > 0) currentLane--;
                } else if (e.key === 'ArrowRight' || e.key === 'd') {
                    if (currentLane < 2) currentLane++;
                } else if (e.key === ' ' || e.key === 'ArrowUp') {
                    if (!isJumping) {
                        isJumping = true;
                        jumpVelocity = 0.4;
                    }
                }
            });
            
            // Touch
            const container = document.getElementById('game-container');
            
            container.addEventListener('touchstart', (e) => {
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
            });
            
            container.addEventListener('touchend', (e) => {
                if (!gameStarted || gameOver) return;
                
                const dx = e.changedTouches[0].clientX - touchStartX;
                const dy = e.changedTouches[0].clientY - touchStartY;
                
                if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > 30) {
                    // Horizontal swipe
                    if (dx > 0 && currentLane < 2) currentLane++;
                    else if (dx < 0 && currentLane > 0) currentLane--;
                } else if (Math.abs(dy) < 30 || dy < -30) {
                    // Tap or swipe up = jump
                    if (!isJumping) {
                        isJumping = true;
                        jumpVelocity = 0.4;
                    }
                }
            });
        }
        
        function update() {
            if (!gameStarted || gameOver) return;
            
            // Update score
            distance += speed;
            score = Math.floor(distance);
            document.getElementById('score').textContent = 'SCORE: ' + score;
            document.getElementById('distance').textContent = Math.floor(distance) + 'm';
            
            // Increase speed
            speed = 0.5 + distance * 0.0001;
            
            // Move Bulk to lane
            const targetX = lanePositions[currentLane];
            bulk.position.x += (targetX - bulk.position.x) * 0.2;
            
            // Jump physics
            if (isJumping) {
                jumpVelocity += gravity;
                bulk.position.y += jumpVelocity;
                if (bulk.position.y <= 0) {
                    bulk.position.y = 0;
                    isJumping = false;
                }
            }
            
            // Running animation
            if (!isJumping) {
                bulk.position.y = Math.sin(Date.now() * 0.02) * 0.2;
            }
            
            // Move ground
            ground.forEach(tile => {
                tile.position.z += speed;
                if (tile.position.z > 20) {
                    tile.position.z -= 400;
                }
            });
            
            // Spawn obstacles
            if (Math.random() < 0.02) {
                createObstacle();
            }
            
            // Move and check obstacles
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obs = obstacles[i];
                obs.position.z += speed;
                
                // Collision check
                if (obs.position.z > -2 && obs.position.z < 2) {
                    if (Math.abs(bulk.position.x - obs.position.x) < 2) {
                        if (bulk.position.y < 2.5) {
                            // Hit!
                            endGame();
                            return;
                        }
                    }
                }
                
                // Remove passed obstacles
                if (obs.position.z > 10) {
                    scene.remove(obs);
                    obstacles.splice(i, 1);
                }
            }
            
            // Camera follows
            camera.position.x += (bulk.position.x - camera.position.x) * 0.1;
        }
        
        function animate() {
            requestAnimationFrame(animate);
            update();
            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }
        }
        
        function startGame() {
            document.getElementById('title-screen').classList.add('hidden');
            document.getElementById('hud').style.display = 'block';
            gameStarted = true;
        }
        
        function endGame() {
            gameOver = true;
            document.getElementById('final-score').textContent = 'SCORE: ' + score;
            document.getElementById('game-over').classList.add('show');
        }
        
        // Handle resize
        window.addEventListener('resize', () => {
            if (camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        });
        
        // Wait for page load then init
        window.addEventListener('load', () => {
            setTimeout(init, 100);
        });
    </script>
</body>
</html>
