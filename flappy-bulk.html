<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>FLAPPY BULK - Tap to Jump!</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Bangers&family=Press+Start+2P&display=swap');

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background: #000;
            overflow: hidden;
            font-family: 'Press Start 2P', monospace;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
        }

        #game-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        canvas {
            display: block;
            background: #000;
        }

        #title-screen {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(135deg, #2d1b4e 0%, #1a0a2e 50%, #0d0d0d 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        #title-screen.hidden { display: none; }

        .title-main {
            font-family: 'Bangers', cursive;
            font-size: clamp(3rem, 10vw, 6rem);
            color: #9b30ff;
            text-shadow: 0 0 20px #ff00ff, 4px 4px 0 #000;
            letter-spacing: 0.1em;
            animation: pulse 0.5s ease-in-out infinite alternate;
        }

        @keyframes pulse {
            from { transform: scale(1); }
            to { transform: scale(1.05); }
        }

        .subtitle {
            font-size: clamp(0.8rem, 2vw, 1.2rem);
            color: #ffd93d;
            margin-top: 20px;
        }

        .instructions {
            font-size: 0.5rem;
            color: #fff;
            margin-top: 30px;
            text-align: center;
            line-height: 2.5;
            max-width: 90%;
        }

        .instructions .highlight {
            color: #39FF14;
            font-size: 0.6rem;
        }

        .start-btn {
            margin-top: 40px;
            padding: 20px 60px;
            font-family: 'Bangers', cursive;
            font-size: clamp(1.5rem, 4vw, 2.5rem);
            background: linear-gradient(180deg, #9b30ff 0%, #6b0099 100%);
            color: #fff;
            border: 4px solid #ff00ff;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 0 30px #9b30ff;
            animation: float 1s ease-in-out infinite;
            transition: transform 0.2s;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        .start-btn:hover { transform: scale(1.1); }
        .start-btn:active { transform: scale(0.95); }

        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            color: #fff;
            font-size: 14px;
            text-shadow: 2px 2px 0 #000;
            z-index: 50;
            pointer-events: none;
            display: none;
        }

        #hud.show { display: block; }

        .hud-row {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        #score {
            font-size: 32px;
            color: #ffd93d;
            text-shadow: 0 0 10px #ffd93d, 3px 3px 0 #000;
        }

        #high-score {
            margin-top: 5px;
            font-size: 12px;
            color: #9b30ff;
        }

        #rage-meter-container {
            text-align: right;
        }

        #rage-meter-label {
            font-size: 10px;
            color: #ff00ff;
            margin-bottom: 5px;
        }

        #rage-meter {
            width: 150px;
            height: 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #9b30ff;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 0 10px rgba(155, 48, 255, 0.5);
        }

        #rage-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #9b30ff 0%, #ff00ff 100%);
            transition: width 0.3s ease;
            box-shadow: 0 0 10px #ff00ff;
        }

        #rage-fill.full {
            animation: ragePulse 0.5s ease-in-out infinite alternate;
        }

        @keyframes ragePulse {
            from { box-shadow: 0 0 10px #ff00ff; }
            to { box-shadow: 0 0 20px #ff00ff, 0 0 30px #ff00ff; }
        }

        #tap-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            color: #39FF14;
            text-shadow: 0 0 20px #39FF14, 3px 3px 0 #000;
            opacity: 0;
            pointer-events: none;
            z-index: 60;
            animation: tapPop 0.3s ease-out;
        }

        @keyframes tapPop {
            0% { opacity: 1; transform: translate(-50%, -50%) scale(0.5); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
        }

        #rage-overlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: radial-gradient(circle, rgba(255,0,255,0.2) 0%, rgba(155,48,255,0.1) 100%);
            pointer-events: none;
            z-index: 40;
            display: none;
            animation: rageFlash 0.3s ease-in-out infinite alternate;
        }

        #rage-overlay.active { display: block; }

        @keyframes rageFlash {
            from { opacity: 0.3; }
            to { opacity: 0.6; }
        }

        #game-over {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        #game-over.show { display: flex; }

        .game-over-title {
            font-family: 'Bangers', cursive;
            font-size: clamp(2.5rem, 8vw, 5rem);
            color: #ff0000;
            text-shadow: 0 0 20px #ff0000, 4px 4px 0 #000;
            margin-bottom: 30px;
        }

        .final-score, .high-score-display {
            font-size: clamp(1.2rem, 3vw, 2rem);
            color: #ffd93d;
            text-shadow: 0 0 10px #ffd93d, 2px 2px 0 #000;
            margin: 10px 0;
        }

        .high-score-display {
            color: #9b30ff;
            text-shadow: 0 0 10px #9b30ff, 2px 2px 0 #000;
        }

        .restart-btn {
            margin-top: 30px;
            padding: 15px 50px;
            font-family: 'Bangers', cursive;
            font-size: clamp(1.2rem, 3vw, 2rem);
            background: linear-gradient(180deg, #39FF14 0%, #2a9e0f 100%);
            color: #000;
            border: 4px solid #39FF14;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 0 20px #39FF14;
            animation: float 1s ease-in-out infinite;
            transition: transform 0.2s;
        }

        .restart-btn:hover { transform: scale(1.1); }
        .restart-btn:active { transform: scale(0.95); }

        .back-link {
            margin-top: 20px;
            padding: 10px 30px;
            font-size: 0.8rem;
            color: #9b30ff;
            text-decoration: none;
            border: 2px solid #9b30ff;
            border-radius: 5px;
            transition: all 0.3s;
        }

        .back-link:hover {
            background: #9b30ff;
            color: #fff;
            box-shadow: 0 0 15px #9b30ff;
        }

        @media (max-width: 768px) {
            .title-main {
                font-size: clamp(2.5rem, 8vw, 4rem);
            }

            .instructions {
                font-size: 0.45rem;
                padding: 0 20px;
            }

            .instructions .highlight {
                font-size: 0.5rem;
            }

            .start-btn, .restart-btn {
                font-size: clamp(1.2rem, 3vw, 2rem);
                padding: 15px 40px;
            }

            #score {
                font-size: 28px;
            }

            #rage-meter {
                width: 120px;
            }
        }

        @media (max-width: 480px) {
            .title-main {
                font-size: 2rem;
            }

            #score {
                font-size: 24px;
            }

            #rage-meter {
                width: 100px;
                height: 15px;
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>

        <div id="title-screen">
            <div class="title-main">FLAPPY BULK</div>
            <div class="subtitle">TAP TO JUMP!</div>
            <div class="instructions">
                <span class="highlight">1 TAP</span> = Small Jump (Cars)<br>
                <span class="highlight">2 TAPS</span> = Medium Jump<br>
                <span class="highlight">3+ TAPS</span> = High Jump (Buildings)<br><br>
                Collect purple orbs for <span class="highlight">RAGE MODE</span>!
            </div>
            <button class="start-btn" onclick="startGame()">START</button>
        </div>

        <div id="hud">
            <div class="hud-row">
                <div>
                    <div id="score">0</div>
                    <div id="high-score">BEST: 0</div>
                </div>
                <div id="rage-meter-container">
                    <div id="rage-meter-label">RAGE</div>
                    <div id="rage-meter">
                        <div id="rage-fill"></div>
                    </div>
                </div>
            </div>
        </div>

        <div id="tap-indicator"></div>
        <div id="rage-overlay"></div>

        <div id="game-over">
            <div class="game-over-title">BULK FELL!</div>
            <div class="final-score" id="final-score">SCORE: 0</div>
            <div class="high-score-display" id="high-score-display">BEST: 0</div>
            <button class="restart-btn" onclick="restartGame()">TRY AGAIN</button>
            <a href="index.html" class="back-link">BACK TO HOME</a>
        </div>
    </div>

    <script>
        // === CONSTANTS ===
        const GameState = {
            TITLE: 'title',
            PLAYING: 'playing',
            GAME_OVER: 'game_over'
        };

        // === STATE ===
        let currentState = GameState.TITLE;
        let gameStarted = false;
        let gameOver = false;
        let score = 0;
        let highScore = localStorage.getItem('flappyBulkHighScore') || 0;

        // === CANVAS SETUP ===
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // === GAME OBJECTS ===
        const GROUND_HEIGHT = 100;
        const GRAVITY = 0.8;
        const MAX_FALL_SPEED = 15;
        const TAP_WINDOW = 300; // milliseconds
        const SCROLL_SPEED = 5;
        const OBSTACLE_SPAWN_DISTANCE = 400;

        const bulk = {
            x: canvas.width / 4,
            y: 0,
            width: 50,
            height: 50,
            velocity: 0,
            isOnGround: true,
            tapCount: 0,
            lastTapTime: 0,
            isRaging: false,
            runAnimation: 0
        };

        let obstacles = [];
        let powerUps = [];
        let particles = [];
        let rageMeter = 0;
        let rageTimer = 0;
        let lastObstacleX = canvas.width;
        let bgScrollX = 0;
        let roadScrollX = 0;

        // === INITIALIZATION ===
        function init() {
            bulk.y = getGroundY();
            bulk.isOnGround = true;
            bulk.velocity = 0;
            bulk.tapCount = 0;
            obstacles = [];
            powerUps = [];
            particles = [];
            rageMeter = 0;
            rageTimer = 0;
            lastObstacleX = canvas.width;
            bgScrollX = 0;
            roadScrollX = 0;
            updateHighScoreDisplay();
        }

        function getGroundY() {
            return canvas.height - GROUND_HEIGHT - bulk.height;
        }

        // === UPDATE FUNCTIONS ===
        function updateBulk() {
            // Apply gravity when in air
            if (!bulk.isOnGround) {
                bulk.velocity += GRAVITY;
                if (bulk.velocity > MAX_FALL_SPEED) {
                    bulk.velocity = MAX_FALL_SPEED;
                }
            }

            // Update position
            bulk.y += bulk.velocity;

            // Ground collision
            const groundY = getGroundY();
            if (bulk.y >= groundY) {
                bulk.y = groundY;
                bulk.velocity = 0;
                bulk.isOnGround = true;
            } else {
                bulk.isOnGround = false;
            }

            // Update running animation
            bulk.runAnimation += 0.2;
            if (bulk.runAnimation >= 4) bulk.runAnimation = 0;
        }

        function updateObstacles() {
            // Spawn obstacles
            if (obstacles.length === 0 || canvas.width - obstacles[obstacles.length - 1].x > OBSTACLE_SPAWN_DISTANCE) {
                spawnObstacle();
            }

            // Move obstacles
            obstacles.forEach((obstacle, index) => {
                obstacle.x -= SCROLL_SPEED;

                // Score when passed
                if (!obstacle.scored && obstacle.x + obstacle.width < bulk.x) {
                    obstacle.scored = true;
                    if (!bulk.isRaging) {
                        addScore(1);
                    }
                }
            });

            // Remove off-screen obstacles
            obstacles = obstacles.filter(obs => obs.x + obs.width > -100);
        }

        function spawnObstacle() {
            const isBuilding = Math.random() > 0.6;

            if (isBuilding) {
                // Building
                const height = 250 + Math.random() * 100;
                obstacles.push({
                    type: 'building',
                    x: canvas.width,
                    y: canvas.height - GROUND_HEIGHT - height,
                    width: 150 + Math.random() * 100,
                    height: height,
                    color: '#2d1b4e',
                    scored: false,
                    windows: generateWindows(150, height)
                });
            } else {
                // Car
                const height = 60 + Math.random() * 20;
                const colors = ['#ff0000', '#ffff00', '#00ffff', '#ff00ff', '#00ff00'];
                obstacles.push({
                    type: 'car',
                    x: canvas.width,
                    y: canvas.height - GROUND_HEIGHT - height,
                    width: 100 + Math.random() * 50,
                    height: height,
                    color: colors[Math.floor(Math.random() * colors.length)],
                    scored: false
                });
            }

            // Randomly spawn power-up
            if (Math.random() > 0.85 && powerUps.length < 2) {
                spawnPowerUp();
            }
        }

        function generateWindows(buildingWidth, buildingHeight) {
            const windows = [];
            const rows = Math.floor(buildingHeight / 40);
            const cols = Math.floor(buildingWidth / 30);

            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    if (Math.random() > 0.3) { // 70% chance of window
                        windows.push({
                            x: c * 30 + 10,
                            y: r * 40 + 10,
                            lit: Math.random() > 0.4
                        });
                    }
                }
            }

            return windows;
        }

        function spawnPowerUp() {
            powerUps.push({
                x: canvas.width + 100,
                y: canvas.height - GROUND_HEIGHT - 30,
                width: 30,
                height: 30,
                collected: false,
                pulse: 0
            });
        }

        function updatePowerUps() {
            powerUps.forEach(powerUp => {
                powerUp.x -= SCROLL_SPEED;
                powerUp.pulse += 0.1;
            });

            powerUps = powerUps.filter(p => p.x > -50 && !p.collected);
        }

        function updateParticles() {
            particles.forEach(particle => {
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.life -= 0.02;
                particle.alpha = particle.life;
            });

            particles = particles.filter(p => p.life > 0);
        }

        function updateRageMode() {
            if (bulk.isRaging) {
                rageTimer -= 1/60; // Assuming 60fps

                // Create trail particles
                if (Math.random() > 0.7) {
                    createParticle(bulk.x + bulk.width/2, bulk.y + bulk.height/2, '#ff00ff');
                }

                if (rageTimer <= 0) {
                    deactivateRageMode();
                }
            }
        }

        function createParticle(x, y, color) {
            particles.push({
                x: x,
                y: y,
                vx: (Math.random() - 0.5) * 4,
                vy: (Math.random() - 0.5) * 4,
                life: 1,
                alpha: 1,
                color: color
            });
        }

        // === JUMP SYSTEM ===
        function handleTap() {
            if (!gameStarted || gameOver) return;

            const now = Date.now();

            // Check if within tap window
            if (now - bulk.lastTapTime < TAP_WINDOW) {
                bulk.tapCount++;
            } else {
                bulk.tapCount = 1;
            }

            bulk.lastTapTime = now;

            // Show tap indicator
            showTapIndicator(bulk.tapCount);

            // Apply jump after short delay to allow for multi-tap
            setTimeout(() => {
                if (Date.now() - bulk.lastTapTime >= TAP_WINDOW * 0.8) {
                    applyJump(bulk.tapCount);
                }
            }, TAP_WINDOW * 0.9);
        }

        function applyJump(tapCount) {
            let jumpStrength = -12;

            if (tapCount >= 3) {
                jumpStrength = -20;
            } else if (tapCount === 2) {
                jumpStrength = -16;
            }

            bulk.velocity = jumpStrength;
            bulk.isOnGround = false;
            bulk.tapCount = 0;
        }

        function showTapIndicator(tapCount) {
            const indicator = document.getElementById('tap-indicator');
            let text = '';

            if (tapCount === 1) text = 'TAP!';
            else if (tapCount === 2) text = 'TAP! TAP!';
            else if (tapCount >= 3) text = 'JUMP!!!';

            indicator.textContent = text;
            indicator.style.animation = 'none';
            setTimeout(() => {
                indicator.style.animation = 'tapPop 0.3s ease-out';
            }, 10);
        }

        // === RAGE MODE ===
        function activateRageMode() {
            bulk.isRaging = true;
            rageTimer = 10; // 10 seconds
            document.getElementById('rage-overlay').classList.add('active');

            // Visual feedback
            for (let i = 0; i < 20; i++) {
                createParticle(
                    bulk.x + bulk.width/2 + (Math.random() - 0.5) * 100,
                    bulk.y + bulk.height/2 + (Math.random() - 0.5) * 100,
                    '#ff00ff'
                );
            }
        }

        function deactivateRageMode() {
            bulk.isRaging = false;
            rageMeter = 0;
            document.getElementById('rage-overlay').classList.remove('active');
            updateRageMeter();
        }

        function updateRageMeter() {
            const fill = document.getElementById('rage-fill');
            fill.style.width = rageMeter + '%';

            if (rageMeter >= 100) {
                fill.classList.add('full');
            } else {
                fill.classList.remove('full');
            }
        }

        function collectPowerUp(powerUp) {
            powerUp.collected = true;
            rageMeter += 100; // Full meter on collect

            if (rageMeter >= 100) {
                rageMeter = 100;
                activateRageMode();
            }

            updateRageMeter();

            // Particle effect
            for (let i = 0; i < 15; i++) {
                createParticle(powerUp.x, powerUp.y, '#9b30ff');
            }
        }

        // === COLLISION DETECTION ===
        function checkCollisions() {
            // Check obstacles
            obstacles.forEach(obstacle => {
                if (checkAABB(bulk, obstacle)) {
                    if (bulk.isRaging) {
                        // Destroy obstacle in rage mode
                        obstacle.scored = true; // Mark to remove
                        obstacle.x = -1000; // Move off screen
                        addScore(5);

                        // Explosion effect
                        for (let i = 0; i < 10; i++) {
                            createParticle(
                                obstacle.x + obstacle.width/2,
                                obstacle.y + obstacle.height/2,
                                '#ff0000'
                            );
                        }

                        // Screen shake (could be enhanced)
                    } else {
                        // Game over
                        endGame();
                    }
                }
            });

            // Check power-ups
            powerUps.forEach(powerUp => {
                if (!powerUp.collected && checkAABB(bulk, powerUp)) {
                    collectPowerUp(powerUp);
                }
            });
        }

        function checkAABB(obj1, obj2) {
            return obj1.x < obj2.x + obj2.width &&
                   obj1.x + obj1.width > obj2.x &&
                   obj1.y < obj2.y + obj2.height &&
                   obj1.y + obj1.height > obj2.y;
        }

        // === SCORING ===
        function addScore(points) {
            score += points;
            document.getElementById('score').textContent = score;

            if (score > highScore) {
                highScore = score;
                localStorage.setItem('flappyBulkHighScore', highScore);
                document.getElementById('high-score').textContent = 'BEST: ' + highScore;
            }
        }

        function updateHighScoreDisplay() {
            document.getElementById('high-score').textContent = 'BEST: ' + highScore;
        }

        // === RENDERING ===
        function drawBackground() {
            // Sky gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#2d1b4e');
            gradient.addColorStop(0.6, '#1a0a2e');
            gradient.addColorStop(1, '#0d0d0d');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Parallax cityscape
            bgScrollX -= SCROLL_SPEED * 0.3;
            if (bgScrollX <= -canvas.width) bgScrollX = 0;

            ctx.fillStyle = 'rgba(155, 77, 202, 0.15)';
            for (let i = 0; i < 15; i++) {
                const buildingHeight = 100 + Math.sin(i * 0.5) * 80;
                const buildingWidth = 60 + Math.cos(i * 0.7) * 20;
                const x = bgScrollX + i * 120;

                ctx.fillRect(
                    x,
                    canvas.height - GROUND_HEIGHT - buildingHeight,
                    buildingWidth,
                    buildingHeight
                );

                // Duplicate for seamless scroll
                ctx.fillRect(
                    x + canvas.width,
                    canvas.height - GROUND_HEIGHT - buildingHeight,
                    buildingWidth,
                    buildingHeight
                );
            }
        }

        function drawRoad() {
            // Ground
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, canvas.height - GROUND_HEIGHT, canvas.width, GROUND_HEIGHT);

            // Road stripes
            roadScrollX -= SCROLL_SPEED;
            if (roadScrollX <= -100) roadScrollX = 0;

            ctx.fillStyle = '#ffd93d';
            for (let i = 0; i < canvas.width / 100 + 2; i++) {
                const x = roadScrollX + i * 100;
                ctx.fillRect(x, canvas.height - GROUND_HEIGHT + 45, 60, 10);
            }

            // Ground edge
            ctx.strokeStyle = '#9b30ff';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(0, canvas.height - GROUND_HEIGHT);
            ctx.lineTo(canvas.width, canvas.height - GROUND_HEIGHT);
            ctx.stroke();
        }

        function drawBulk() {
            ctx.save();

            // Rage mode glow
            if (bulk.isRaging) {
                ctx.shadowColor = '#ff00ff';
                ctx.shadowBlur = 30;
            }

            // Body
            ctx.fillStyle = bulk.isRaging ? '#ff00ff' : '#9B4DCA';
            ctx.fillRect(bulk.x, bulk.y, bulk.width, bulk.height);

            // Running animation (legs)
            const legOffset = Math.floor(bulk.runAnimation) % 2 === 0 ? 5 : -5;
            ctx.fillStyle = bulk.isRaging ? '#cc00cc' : '#6B2D9E';
            ctx.fillRect(bulk.x + 10, bulk.y + bulk.height, 12, legOffset + 10);
            ctx.fillRect(bulk.x + 28, bulk.y + bulk.height, 12, -legOffset + 10);

            // Eyes
            ctx.fillStyle = '#fff';
            ctx.fillRect(bulk.x + 12, bulk.y + 15, 8, 8);
            ctx.fillRect(bulk.x + 30, bulk.y + 15, 8, 8);

            // Pupils
            ctx.fillStyle = '#000';
            ctx.fillRect(bulk.x + 15, bulk.y + 18, 4, 4);
            ctx.fillRect(bulk.x + 33, bulk.y + 18, 4, 4);

            // Glow based on tap count
            if (bulk.tapCount > 0 && Date.now() - bulk.lastTapTime < TAP_WINDOW) {
                ctx.shadowColor = '#39FF14';
                ctx.shadowBlur = 15 + bulk.tapCount * 10;
                ctx.strokeStyle = '#39FF14';
                ctx.lineWidth = 2;
                ctx.strokeRect(bulk.x, bulk.y, bulk.width, bulk.height);
            }

            ctx.restore();
        }

        function drawObstacles() {
            obstacles.forEach(obstacle => {
                if (obstacle.type === 'building') {
                    // Building
                    ctx.fillStyle = obstacle.color;
                    ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);

                    // Windows
                    obstacle.windows.forEach(window => {
                        ctx.fillStyle = window.lit ? '#ffd93d' : '#1a0a2e';
                        ctx.fillRect(
                            obstacle.x + window.x,
                            obstacle.y + window.y,
                            15, 20
                        );
                    });

                    // Outline
                    ctx.strokeStyle = '#9b30ff';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                } else {
                    // Car
                    ctx.fillStyle = obstacle.color;
                    ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);

                    // Car details
                    ctx.fillStyle = '#000';
                    ctx.fillRect(obstacle.x + 10, obstacle.y + 10, obstacle.width - 20, obstacle.height - 30);

                    // Wheels
                    ctx.fillStyle = '#333';
                    ctx.beginPath();
                    ctx.arc(obstacle.x + 20, obstacle.y + obstacle.height, 10, 0, Math.PI * 2);
                    ctx.arc(obstacle.x + obstacle.width - 20, obstacle.y + obstacle.height, 10, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
        }

        function drawPowerUps() {
            powerUps.forEach(powerUp => {
                if (powerUp.collected) return;

                ctx.save();

                // Pulsing glow
                const pulseSize = Math.sin(powerUp.pulse) * 5;
                ctx.shadowColor = '#9b30ff';
                ctx.shadowBlur = 20;

                // Orb
                ctx.fillStyle = '#9b30ff';
                ctx.beginPath();
                ctx.arc(
                    powerUp.x + powerUp.width/2,
                    powerUp.y + powerUp.height/2,
                    powerUp.width/2 + pulseSize,
                    0,
                    Math.PI * 2
                );
                ctx.fill();

                // Inner glow
                ctx.fillStyle = '#ff00ff';
                ctx.beginPath();
                ctx.arc(
                    powerUp.x + powerUp.width/2,
                    powerUp.y + powerUp.height/2,
                    powerUp.width/4,
                    0,
                    Math.PI * 2
                );
                ctx.fill();

                ctx.restore();
            });
        }

        function drawParticles() {
            particles.forEach(particle => {
                ctx.save();
                ctx.globalAlpha = particle.alpha;
                ctx.fillStyle = particle.color;
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            });
        }

        // === INPUT HANDLERS ===
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' || e.code === 'ArrowUp' || e.key === 'w' || e.key === 'W') {
                e.preventDefault();
                handleTap();
            }
        });

        canvas.addEventListener('click', () => {
            if (currentState === GameState.PLAYING) {
                handleTap();
            }
        });

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (currentState === GameState.PLAYING) {
                handleTap();
            }
        });

        // === GAME FLOW ===
        function startGame() {
            document.getElementById('title-screen').classList.add('hidden');
            document.getElementById('hud').classList.add('show');

            currentState = GameState.PLAYING;
            gameStarted = true;
            gameOver = false;
            score = 0;

            init();
            updateHighScoreDisplay();
            document.getElementById('score').textContent = '0';
        }

        function endGame() {
            if (gameOver) return;

            gameOver = true;
            currentState = GameState.GAME_OVER;

            document.getElementById('final-score').textContent = 'SCORE: ' + score;
            document.getElementById('high-score-display').textContent = 'BEST: ' + highScore;
            document.getElementById('game-over').classList.add('show');

            deactivateRageMode();
        }

        function restartGame() {
            document.getElementById('game-over').classList.remove('show');
            document.getElementById('title-screen').classList.remove('hidden');
            document.getElementById('hud').classList.remove('show');

            currentState = GameState.TITLE;
            gameStarted = false;
            gameOver = false;
            score = 0;

            init();
        }

        // === GAME LOOP ===
        function gameLoop() {
            if (currentState === GameState.PLAYING && !gameOver) {
                // Update
                updateBulk();
                updateObstacles();
                updatePowerUps();
                updateParticles();
                updateRageMode();
                checkCollisions();

                // Render
                drawBackground();
                drawRoad();
                drawObstacles();
                drawPowerUps();
                drawBulk();
                drawParticles();
            }

            requestAnimationFrame(gameLoop);
        }

        // === START ===
        init();
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
